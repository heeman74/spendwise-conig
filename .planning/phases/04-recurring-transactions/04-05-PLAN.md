---
phase: 04-recurring-transactions
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - spendwise/src/hooks/useRecurring.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Dismissing a recurring item removes it from the active list AND adds it to the dismissed section immediately"
    - "Restoring a dismissed recurring item removes it from the dismissed section AND returns it to the active list immediately"
    - "Both active and dismissed query instances update correctly after any mutation"
  artifacts:
    - path: "spendwise/src/hooks/useRecurring.ts"
      provides: "Proper Apollo cache invalidation for dismiss/restore/add mutations"
      contains: "refetchQueries"
  key_links:
    - from: "spendwise/src/hooks/useRecurring.ts"
      to: "spendwise/src/graphql/queries/recurring.ts"
      via: "GET_RECURRING and GET_RECURRING_SUMMARY query documents in refetchQueries"
      pattern: "GET_RECURRING"
---

<objective>
Fix Apollo cache invalidation so dismiss and restore mutations properly update both the active and dismissed recurring transaction lists.

Purpose: UAT revealed that restoring a dismissed recurring transaction doesn't update the dismissed items list in the UI. The backend mutation works correctly (sets isDismissed: false), but the UI doesn't reflect the change because Apollo's string-based refetchQueries ('GetRecurring') doesn't properly coordinate both query instances that use the same operation name with different variables (dismissed: false vs dismissed: true).

Output: All mutation hooks in useRecurring.ts use document-based refetchQueries that force Apollo to refetch all active instances of the GetRecurring query regardless of their variables.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-recurring-transactions/04-03-SUMMARY.md
@spendwise/src/hooks/useRecurring.ts
@spendwise/src/graphql/queries/recurring.ts
@spendwise/src/graphql/mutations/recurring.ts
@spendwise/src/app/(dashboard)/recurring/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix refetchQueries in all mutation hooks to use query documents instead of operation name strings</name>
  <files>
    spendwise/src/hooks/useRecurring.ts
  </files>
  <action>
    The root cause: The recurring page calls `useRecurring({ dismissed: false })` and `useRecurring({ dismissed: true })`. Both execute the `GetRecurring` query but with different variables. When a mutation uses `refetchQueries: ['GetRecurring']`, Apollo may not properly refetch ALL instances of that query with different variables.

    Fix approach: Change all mutation hooks from string-based to document-based refetchQueries, and add `awaitRefetchQueries: true` to ensure the UI waits for the refetch to complete before updating.

    Specific changes to useRecurring.ts:

    1. Import the query documents at the top: `import { GET_RECURRING, GET_RECURRING_SUMMARY } from '@/graphql';` (these are already imported, just verify they're available)

    2. In ALL mutation hooks (useUpdateRecurring, useDismissRecurring, useRestoreRecurring, useAddRecurring), replace:
       ```
       refetchQueries: ['GetRecurring', 'GetRecurringSummary'],
       ```
       with:
       ```
       refetchQueries: [
         { query: GET_RECURRING, variables: { dismissed: false } },
         { query: GET_RECURRING, variables: { dismissed: true } },
         { query: GET_RECURRING_SUMMARY },
       ],
       awaitRefetchQueries: true,
       ```

    This explicitly tells Apollo to refetch BOTH the active (dismissed: false) and dismissed (dismissed: true) queries, plus the summary. The `awaitRefetchQueries: true` ensures the mutation's returned promise doesn't resolve until all refetches complete, preventing UI flash.

    NOTE: The dismissed: true query on the page doesn't pass filters or sort, so `{ dismissed: true }` is sufficient. The dismissed: false query on the page passes filters and sort, but Apollo matches refetch queries by the query document + variables subset — the refetch will trigger for any active query using GET_RECURRING with dismissed: false in its variables, regardless of additional filter/sort variables. Actually, to be safe, do NOT include the filter/sort variables in the refetch — just include `dismissed` as the key variable. Apollo will refetch any active query matching the query document. An even simpler approach: use `'active'` as the refetchQueries value to refetch ALL active queries:

    Actually, the most reliable approach: use `refetchQueries: 'active'` which tells Apollo to refetch ALL active queries. But this is too broad.

    The correct approach: Use the `include` option with `'active'` to refetch all queries that are currently being observed. But actually, the simplest and most targeted fix is:

    Replace string-based with document-based but WITHOUT specifying variables. When you pass `{ query: GET_RECURRING }` without variables, Apollo refetches ALL active instances of that query regardless of their variables. This is the correct fix:

    ```typescript
    refetchQueries: [
      { query: GET_RECURRING },
      { query: GET_RECURRING_SUMMARY },
    ],
    awaitRefetchQueries: true,
    ```

    This tells Apollo: "refetch every active GetRecurring query (regardless of variables) and every active GetRecurringSummary query." This correctly handles both the dismissed:false and dismissed:true instances.

    Apply this pattern to ALL four mutation hooks: useUpdateRecurring, useDismissRecurring, useRestoreRecurring, useAddRecurring.

    The import for GET_RECURRING and GET_RECURRING_SUMMARY already exists at the top of the file. Just change the refetchQueries arrays.
  </action>
  <verify>
    1. Run `cd /Users/heechung/projects/spendwise && npx tsc --noEmit 2>&1 | grep -i "useRecurring" | head -10` — no type errors
    2. Run `cd /Users/heechung/projects/spendwise && npm run build 2>&1 | tail -10` — build passes
    3. Manual test: Navigate to /recurring, dismiss an item, verify it moves to dismissed section. Expand dismissed section, restore the item, verify it returns to active list and disappears from dismissed section.
  </verify>
  <done>
    All four mutation hooks use document-based refetchQueries with `{ query: GET_RECURRING }` (no variables = refetches all instances). Both the active list (dismissed: false) and dismissed list (dismissed: true) update immediately after any mutation. awaitRefetchQueries ensures no UI flash.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/heechung/projects/spendwise && npm run build` passes without errors
2. Navigate to /recurring page
3. Dismiss an active recurring item — it disappears from active list and appears in dismissed section
4. Expand dismissed section, click restore on the item — it disappears from dismissed list and reappears in active list
5. Both transitions happen immediately without requiring page refresh
</verification>

<success_criteria>
- Dismiss mutation causes item to move from active to dismissed list in real-time
- Restore mutation causes item to move from dismissed to active list in real-time
- No page refresh required for either operation
- Summary cards update after dismiss/restore
- Build passes, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-recurring-transactions/04-05-SUMMARY.md`
</output>
