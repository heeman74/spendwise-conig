---
phase: 04-recurring-transactions
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - spendwise/prisma/schema.prisma
  - spendwise-api/prisma/schema.prisma
  - spendwise-api/src/lib/recurring-detector.ts
  - spendwise-api/src/__tests__/lib/recurring-detector.test.ts
autonomous: true

must_haves:
  truths:
    - "Detection algorithm identifies recurring patterns from 3+ transactions with consistent intervals"
    - "Merchant names are normalized so variations of same merchant group together"
    - "Frequency classification correctly maps intervals to weekly/biweekly/monthly/quarterly/annual"
    - "Amount tolerance of 10% allows price variations without breaking detection"
    - "Multiple recurring patterns from same merchant are detected separately"
    - "Habitual spending (high frequency, variable amounts) is excluded from detection"
  artifacts:
    - path: "spendwise-api/src/lib/recurring-detector.ts"
      provides: "Delta-t interval detection algorithm with merchant normalization"
      exports: ["detectRecurringPatterns", "normalizeMerchant", "classifyFrequency", "normalizeToMonthly"]
    - path: "spendwise-api/src/__tests__/lib/recurring-detector.test.ts"
      provides: "Unit tests for detection algorithm"
      min_lines: 100
    - path: "spendwise/prisma/schema.prisma"
      provides: "Extended RecurringTransaction model with isDismissed, nextExpectedDate, status"
      contains: "isDismissed"
    - path: "spendwise-api/prisma/schema.prisma"
      provides: "Same schema extension (synced)"
      contains: "isDismissed"
  key_links:
    - from: "spendwise-api/src/lib/recurring-detector.ts"
      to: "date-fns"
      via: "differenceInDays for interval calculation"
      pattern: "differenceInDays"
---

<objective>
Extend the RecurringTransaction Prisma model with fields needed for custom detection (isDismissed, nextExpectedDate, status), then implement and test the core recurring transaction detection algorithm using TDD.

Purpose: The detection algorithm is the foundation of Phase 4 — it takes raw transaction data and identifies recurring patterns (subscriptions, bills, paychecks). TDD ensures correctness of the business logic before wiring into GraphQL or UI.

Output: Extended Prisma schema (both projects), tested detection algorithm in `recurring-detector.ts`
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-recurring-transactions/04-CONTEXT.md
@.planning/phases/04-recurring-transactions/04-RESEARCH.md
@spendwise/prisma/schema.prisma
@spendwise-api/src/lib/constants.ts
</context>

<feature>
  <name>Recurring Transaction Detection Algorithm</name>
  <files>
    spendwise/prisma/schema.prisma
    spendwise-api/prisma/schema.prisma
    spendwise-api/src/lib/recurring-detector.ts
    spendwise-api/src/__tests__/lib/recurring-detector.test.ts
  </files>
  <behavior>
    The detection algorithm takes an array of transactions and returns detected recurring patterns.

    **Schema changes** (apply to BOTH prisma schemas):
    Add to RecurringTransaction model:
    - `isDismissed  Boolean   @default(false)` — soft delete for user dismissal
    - `nextExpectedDate DateTime?` — predicted next occurrence
    - `status  String  @default("ACTIVE")` — "ACTIVE" or "POSSIBLY_CANCELLED"
    - Make `plaidStreamId` optional (`String? @unique`) since custom detection won't have Plaid IDs — generate a custom stream ID (cuid) instead
    - Make `description` have a default empty string since detection won't always have a description
    - Add `@@unique([userId, merchantName, frequency])` compound unique for upsert support (remove the requirement for plaidStreamId in upserts)

    After schema changes, run `cd spendwise && npx prisma db push` and `cd spendwise-api && npx prisma generate`.

    **Algorithm behavior (testable cases):**

    `normalizeMerchant(raw: string): string`
    - "NETFLIX.COM" -> "netflix"
    - "AMZN*MARKETPLACE" -> "amznmarketplace"
    - "Spotify USA Inc." -> "spotify usa"
    - "SHELL OIL 04821" -> "shell oil"
    - Strips: special chars except spaces, trailing inc/llc/corp/ltd/co/com, long numbers (4+ digits), asterisks, extra whitespace

    `classifyFrequency(avgDays: number): Frequency | null`
    - 7 -> "WEEKLY" (range: 5-9)
    - 14 -> "BIWEEKLY" (range: 11-17)
    - 30 -> "MONTHLY" (range: 25-35)
    - 90 -> "QUARTERLY" (range: 82-98)
    - 365 -> "ANNUALLY" (range: 340-390)
    - 50 -> null (no match)

    `normalizeToMonthly(amount: number, frequency: Frequency): number`
    - (10, "WEEKLY") -> 43.3
    - (100, "BIWEEKLY") -> 217
    - (50, "MONTHLY") -> 50
    - (300, "QUARTERLY") -> 100
    - (120, "ANNUALLY") -> 10

    `detectRecurringPatterns(transactions: Transaction[]): RecurringPattern[]`
    - 3 Netflix charges at $15.99 on Jan 1, Feb 1, Mar 1 -> 1 monthly pattern (merchant: "netflix", frequency: "MONTHLY", avgAmount: ~15.99)
    - 2 Spotify charges -> no pattern (minimum 3)
    - 5 weekly gym charges at $25 -> 1 weekly pattern
    - Netflix $9.99 monthly + Netflix $15.99 monthly (different amounts = different subscriptions) -> 2 separate patterns via amount grouping
    - Starbucks with 15 transactions, varying amounts ($4-$8) -> excluded (habitual spending: high count, variable amounts)
    - 4 transactions with inconsistent intervals (10, 45, 12 days) -> no pattern (intervals not consistent)
    - Charges at $9.99, $9.99, $10.49 (within 10% tolerance) -> grouped together
    - Missed payment detection: if last transaction > 2 expected intervals ago, status = "POSSIBLY_CANCELLED"
    - Next expected date: lastDate + average interval

    **Types (exported from recurring-detector.ts):**
    ```typescript
    type Frequency = 'WEEKLY' | 'BIWEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'ANNUALLY';

    interface TransactionInput {
      id: string;
      date: Date;
      amount: number;
      merchant: string | null;
      category: string;
      type: 'INCOME' | 'EXPENSE' | 'TRANSFER';
    }

    interface RecurringPattern {
      merchantName: string;
      frequency: Frequency;
      averageAmount: number;
      lastAmount: number;
      lastDate: Date;
      firstDate: Date;
      nextExpectedDate: Date;
      transactionIds: string[];
      category: string;
      status: 'ACTIVE' | 'POSSIBLY_CANCELLED';
      description: string;
    }
    ```
  </behavior>
  <implementation>
    1. Extend Prisma schemas first, push to DB, generate clients
    2. Write tests for normalizeMerchant, classifyFrequency, normalizeToMonthly (pure functions)
    3. Write tests for detectRecurringPatterns (complex logic)
    4. Implement all functions to pass tests
    5. Use date-fns differenceInDays and addDays for interval calculations
    6. Group transactions by normalized merchant name, then sub-group by amount range (10% tolerance)
    7. For each group with 3+ transactions, calculate delta-t intervals between consecutive dates
    8. If intervals are consistent (all within 20% of average), classify frequency
    9. Multi-pattern detection: after finding one pattern, remove matched transactions from pool and retry
    10. Habitual spending filter: skip groups with >10 transactions per month AND amount variance >20%
    11. Calculate nextExpectedDate from lastDate + average interval using addDays
    12. Set status to POSSIBLY_CANCELLED if current date > nextExpectedDate + 2 intervals
  </implementation>
</feature>

<verification>
```bash
cd /Users/heechung/projects/spendwise-api && npm test -- --testPathPattern="recurring-detector"
cd /Users/heechung/projects/spendwise && npx prisma validate
cd /Users/heechung/projects/spendwise-api && npx prisma validate
```
</verification>

<success_criteria>
- All unit tests pass for normalizeMerchant, classifyFrequency, normalizeToMonthly, detectRecurringPatterns
- Prisma schema validates in both projects with new fields (isDismissed, nextExpectedDate, status)
- Detection correctly identifies monthly Netflix, weekly gym, excludes habitual Starbucks
- Multiple patterns from same merchant detected separately
- Amount tolerance handles price changes
- Missed payment detection flags stale subscriptions
</success_criteria>

<output>
After completion, create `.planning/phases/04-recurring-transactions/04-01-SUMMARY.md`
</output>
