---
phase: 04-recurring-transactions
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - spendwise-api/src/schema/typeDefs/recurring.ts
  - spendwise-api/src/schema/typeDefs/index.ts
  - spendwise-api/src/schema/resolvers/recurring.ts
  - spendwise-api/src/schema/resolvers/index.ts
  - spendwise-api/src/schema/resolvers/statementImport.ts
autonomous: true

must_haves:
  truths:
    - "GraphQL query 'recurring' returns list of recurring transactions with filtering and sorting"
    - "GraphQL query 'recurringSummary' returns total expenses, income, net, and active count normalized to monthly"
    - "GraphQL mutation 'updateRecurring' allows editing merchant name, frequency, amount, and category"
    - "GraphQL mutation 'dismissRecurring' soft-deletes a recurring item (recoverable)"
    - "GraphQL mutation 'restoreRecurring' un-dismisses a recurring item"
    - "GraphQL mutation 'addRecurring' creates a manual recurring entry"
    - "GraphQL mutation 'detectRecurring' triggers manual re-scan for a user"
    - "After statement import confirms, recurring detection runs automatically for that user"
  artifacts:
    - path: "spendwise-api/src/schema/typeDefs/recurring.ts"
      provides: "GraphQL type definitions for RecurringTransaction, RecurringSummary, filters, inputs"
      exports: ["recurringTypeDefs"]
    - path: "spendwise-api/src/schema/resolvers/recurring.ts"
      provides: "Query and Mutation resolvers for recurring transactions"
      exports: ["recurringResolvers"]
  key_links:
    - from: "spendwise-api/src/schema/resolvers/recurring.ts"
      to: "spendwise-api/src/lib/recurring-detector.ts"
      via: "import detectRecurringPatterns for detectRecurring mutation"
      pattern: "detectRecurringPatterns"
    - from: "spendwise-api/src/schema/resolvers/statementImport.ts"
      to: "spendwise-api/src/lib/recurring-detector.ts"
      via: "post-import trigger calling detection after confirmImport succeeds"
      pattern: "detectRecurringPatterns|detectAndStore"
    - from: "spendwise-api/src/schema/resolvers/index.ts"
      to: "spendwise-api/src/schema/resolvers/recurring.ts"
      via: "spread recurringResolvers into Query and Mutation objects"
      pattern: "recurringResolvers"
    - from: "spendwise-api/src/schema/typeDefs/index.ts"
      to: "spendwise-api/src/schema/typeDefs/recurring.ts"
      via: "import and add to typeDefs array"
      pattern: "recurringTypeDefs"
---

<objective>
Create the GraphQL API layer for recurring transactions (type definitions, resolvers, mutations) and wire the detection algorithm into the statement import flow as a post-import trigger.

Purpose: Expose recurring transaction data and operations via GraphQL so the frontend can list, filter, sort, edit, dismiss, and manually add recurring items. The post-import trigger ensures detection runs automatically whenever new transactions are imported.

Output: Complete GraphQL API for recurring transactions, automatic detection trigger on import
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-recurring-transactions/04-CONTEXT.md
@.planning/phases/04-recurring-transactions/04-RESEARCH.md
@.planning/phases/04-recurring-transactions/04-01-SUMMARY.md
@spendwise-api/src/schema/typeDefs/index.ts
@spendwise-api/src/schema/typeDefs/analytics.ts
@spendwise-api/src/schema/resolvers/index.ts
@spendwise-api/src/schema/resolvers/analytics.ts
@spendwise-api/src/schema/resolvers/statementImport.ts
@spendwise-api/src/lib/recurring-detector.ts
@spendwise-api/src/context/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphQL type definitions and resolvers for recurring transactions</name>
  <files>
    spendwise-api/src/schema/typeDefs/recurring.ts
    spendwise-api/src/schema/typeDefs/index.ts
    spendwise-api/src/schema/resolvers/recurring.ts
    spendwise-api/src/schema/resolvers/index.ts
  </files>
  <action>
    **TypeDefs (recurring.ts):**

    Create `recurringTypeDefs` with gql tag containing:

    Types:
    - `RecurringTransaction` — id, userId, description, merchantName, category, frequency (String), isActive, isDismissed, lastAmount (Decimal), averageAmount (Decimal), lastDate (DateTime), firstDate (DateTime), nextExpectedDate (DateTime), status (String), transactionIds ([String!]!), createdAt, updatedAt
    - `RecurringSummary` — totalRecurringExpenses (Float!), totalRecurringIncome (Float!), netRecurring (Float!), activeCount (Int!), incomeRatio (Float) (recurring expenses as % of recurring income)
    - `RecurringFiltersInput` — frequency (String), category (String), type (String — "INCOME" or "EXPENSE")
    - `RecurringSortInput` — field (String!), order (String!) — "asc" or "desc"
    - `AddRecurringInput` — merchantName (String!), amount (Float!), frequency (String!), category (String!), description (String), firstDate (DateTime!)
    - `UpdateRecurringInput` — merchantName (String), amount (Float), frequency (String), category (String), description (String)

    Queries:
    - `recurring(filters: RecurringFiltersInput, sort: RecurringSortInput, dismissed: Boolean): [RecurringTransaction!]!`
    - `recurringSummary: RecurringSummary!`

    Mutations:
    - `updateRecurring(id: ID!, input: UpdateRecurringInput!): RecurringTransaction!`
    - `dismissRecurring(id: ID!): RecurringTransaction!`
    - `restoreRecurring(id: ID!): RecurringTransaction!`
    - `addRecurring(input: AddRecurringInput!): RecurringTransaction!`
    - `detectRecurring: Int!` (returns count of detected patterns, triggers manual re-scan)

    **Index update (typeDefs/index.ts):**
    Import `recurringTypeDefs` and add to the `typeDefs` array.

    **Resolvers (recurring.ts):**

    Import `detectRecurringPatterns`, `normalizeToMonthly` from `../../lib/recurring-detector`.
    Import `GraphQLError` from `graphql`.
    Import `Context` from `../../context`.

    All resolvers require authentication (`if (!ctx.user) throw GraphQLError('Authentication required', ...)`).

    Query resolvers:
    - `recurring`: Build Prisma where clause from filters. If `dismissed` is explicitly `true`, set `where.isDismissed = true`. If `dismissed` is `false` or undefined, set `where.isDismissed = false` (default shows non-dismissed). Filter by frequency if provided. Filter by category if provided. For type filter: if "INCOME", filter `category: "Income"`, if "EXPENSE", filter `category: { not: "Income" }`. Apply sort via Prisma orderBy (default `lastDate desc`). Return results from `ctx.prisma.recurringTransaction.findMany`.
    - `recurringSummary`: Fetch all active, non-dismissed recurring items for user. Separate into expense and income lists (income = category "Income"). Calculate totalRecurringExpenses and totalRecurringIncome using `normalizeToMonthly` for each item. Calculate netRecurring = income - expenses. Calculate incomeRatio = (totalExpenses / totalIncome * 100) or null if no income. Return summary object.

    Mutation resolvers:
    - `updateRecurring`: Find recurring item by id and userId. Update provided fields (merchantName, amount->lastAmount+averageAmount, frequency, category, description). Return updated item.
    - `dismissRecurring`: Set isDismissed=true on the item. Return updated item.
    - `restoreRecurring`: Set isDismissed=false on the item. Return updated item.
    - `addRecurring`: Create new RecurringTransaction with provided input. Generate a cuid for plaidStreamId (custom stream ID). Set isActive=true, isDismissed=false, status="ACTIVE". Set lastAmount and averageAmount to input.amount. Set lastDate to firstDate. Set transactionIds to empty array. Calculate nextExpectedDate based on frequency and firstDate. Return created item.
    - `detectRecurring`: Fetch all user's transactions from DB. Call `detectRecurringPatterns`. For each pattern, upsert into RecurringTransaction table (match on userId+merchantName+frequency compound unique, or create new). Return count of patterns found.

    **Index update (resolvers/index.ts):**
    Import `recurringResolvers` and spread into Query and Mutation objects.

    Follow existing patterns from analytics.ts resolvers (auth check, Prisma queries, context usage). Use `parseFloat(item.averageAmount.toString())` for Decimal-to-number conversion (Prisma Decimal pattern from research).
  </action>
  <verify>
    ```bash
    cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit
    ```
    TypeScript compilation passes with no errors.
  </verify>
  <done>
    GraphQL API compiles. Types, queries, and mutations are defined. Resolvers handle auth, filtering, sorting, CRUD operations, and detection trigger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire recurring detection trigger into statement import flow</name>
  <files>
    spendwise-api/src/schema/resolvers/statementImport.ts
  </files>
  <action>
    In the `confirmImport` mutation resolver, after the successful import block (after updating the import record to COMPLETED status and before cleaning up Redis cache), add a non-blocking call to detect recurring patterns for the user.

    Import `detectRecurringPatterns` from `../../lib/recurring-detector` at the top of the file.

    After the `// Update import record` block and the `statementImport.update` call with `status: 'COMPLETED'`:

    ```typescript
    // Trigger recurring transaction detection (non-blocking)
    // Detection analyzes full transaction history, not just this import
    try {
      const allTransactions = await ctx.prisma.transaction.findMany({
        where: { userId: ctx.user!.id },
        orderBy: { date: 'asc' },
        select: {
          id: true,
          date: true,
          amount: true,
          merchant: true,
          category: true,
          type: true,
        },
      });

      const patterns = detectRecurringPatterns(
        allTransactions.map(t => ({
          id: t.id,
          date: t.date,
          amount: parseFloat(t.amount.toString()),
          merchant: t.merchant,
          category: t.category,
          type: t.type as 'INCOME' | 'EXPENSE' | 'TRANSFER',
        }))
      );

      // Upsert detected patterns
      for (const pattern of patterns) {
        await ctx.prisma.recurringTransaction.upsert({
          where: {
            userId_merchantName_frequency: {
              userId: ctx.user!.id,
              merchantName: pattern.merchantName,
              frequency: pattern.frequency,
            },
          },
          create: {
            userId: ctx.user!.id,
            plaidStreamId: require('crypto').randomUUID(),
            description: pattern.description,
            merchantName: pattern.merchantName,
            category: pattern.category,
            frequency: pattern.frequency,
            isActive: true,
            isDismissed: false,
            status: pattern.status,
            lastAmount: pattern.lastAmount,
            averageAmount: pattern.averageAmount,
            lastDate: pattern.lastDate,
            firstDate: pattern.firstDate,
            nextExpectedDate: pattern.nextExpectedDate,
            transactionIds: pattern.transactionIds,
          },
          update: {
            lastAmount: pattern.lastAmount,
            averageAmount: pattern.averageAmount,
            lastDate: pattern.lastDate,
            transactionIds: pattern.transactionIds,
            nextExpectedDate: pattern.nextExpectedDate,
            status: pattern.status,
            description: pattern.description,
          },
        });
      }
    } catch (detectError) {
      // Non-blocking: log but don't fail the import
      console.error('Recurring detection failed (non-blocking):', detectError);
    }
    ```

    This must NOT fail the import — wrap in try/catch. Detection errors are logged but don't affect the import success response.

    **Important:** The upsert uses the compound unique `userId_merchantName_frequency` which was added in Plan 01's schema extension. This prevents duplicate recurring items for the same merchant+frequency combination.
  </action>
  <verify>
    ```bash
    cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit
    ```
    TypeScript compiles. The confirmImport mutation still returns success response. Detection failure doesn't break import flow.
  </verify>
  <done>
    Statement import confirmation triggers recurring pattern detection automatically. Detection is non-blocking — import succeeds regardless of detection outcome.
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit

# All existing tests still pass
cd /Users/heechung/projects/spendwise-api && npm test

# Verify GraphQL schema loads (check for errors on startup)
cd /Users/heechung/projects/spendwise-api && timeout 10 npm run dev 2>&1 | head -20 || true
```
</verification>

<success_criteria>
- GraphQL API compiles with all recurring type definitions and resolvers
- recurring query supports filters (frequency, category, type), sort, and dismissed flag
- recurringSummary returns monthly-normalized totals
- All CRUD mutations (update, dismiss, restore, add) work
- detectRecurring mutation triggers full detection scan
- confirmImport triggers detection automatically (non-blocking)
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-recurring-transactions/04-02-SUMMARY.md`
</output>
