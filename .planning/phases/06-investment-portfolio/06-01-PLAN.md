---
phase: 06-investment-portfolio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spendwise-api/src/schema/typeDefs/investment.ts
  - spendwise-api/src/schema/resolvers/investment.ts
  - spendwise-api/src/schema/typeDefs/index.ts
  - spendwise-api/src/schema/resolvers/index.ts
autonomous: true

must_haves:
  truths:
    - "GraphQL portfolio query returns totalValue, totalCostBasis, totalGain, totalGainPercent, holdingCount, accountCount, and accounts array"
    - "GraphQL holdings query returns all holdings with security details, quantity, prices, cost basis, and computed unrealizedGain/unrealizedGainPercent"
    - "GraphQL assetAllocation query returns array of asset types with value, percentage, and color"
    - "addHolding mutation creates a new holding with security lookup-or-create"
    - "updateHoldingPrice mutation updates institutionPrice and recalculates institutionValue"
  artifacts:
    - path: "spendwise-api/src/schema/typeDefs/investment.ts"
      provides: "GraphQL type definitions for InvestmentHolding, Security, Portfolio, AssetAllocation"
      contains: "extend type Query"
    - path: "spendwise-api/src/schema/resolvers/investment.ts"
      provides: "Resolvers for portfolio, holdings, assetAllocation queries and addHolding, updateHoldingPrice mutations"
      exports: ["investmentResolvers"]
  key_links:
    - from: "spendwise-api/src/schema/resolvers/index.ts"
      to: "spendwise-api/src/schema/resolvers/investment.ts"
      via: "spread into Query and Mutation objects"
      pattern: "investmentResolvers"
    - from: "spendwise-api/src/schema/typeDefs/index.ts"
      to: "spendwise-api/src/schema/typeDefs/investment.ts"
      via: "added to typeDefs array"
      pattern: "investmentTypeDefs"
---

<objective>
Build the GraphQL backend for investment portfolio: type definitions, resolvers for portfolio summary, holdings list, asset allocation, and mutations for adding holdings and updating prices.

Purpose: Provides the data layer that all frontend portfolio components will query. Without this, no portfolio data is accessible.
Output: `investment.ts` typeDefs and resolvers, registered in schema indexes.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@spendwise-api/prisma/schema.prisma
@spendwise-api/src/schema/typeDefs/netWorth.ts
@spendwise-api/src/schema/resolvers/netWorth.ts
@spendwise-api/src/schema/typeDefs/index.ts
@spendwise-api/src/schema/resolvers/index.ts
@spendwise-api/src/lib/utils.ts
@spendwise-api/src/lib/redis.ts
@spendwise-api/src/context/index.ts
@spendwise-api/src/middleware/authMiddleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create investment GraphQL type definitions</name>
  <files>spendwise-api/src/schema/typeDefs/investment.ts</files>
  <action>
Create `spendwise-api/src/schema/typeDefs/investment.ts` following the exact pattern from `netWorth.ts` (import gql from graphql-tag, export named const).

Define these types:

```graphql
type Security {
  id: ID!
  name: String!
  tickerSymbol: String
  type: String!
  closePrice: Decimal
  closePriceAsOf: DateTime
  sector: String
  industry: String
}

type InvestmentHolding {
  id: ID!
  accountId: String!
  account: Account!
  securityId: String!
  security: Security!
  quantity: Decimal!
  institutionPrice: Decimal!
  institutionValue: Decimal!
  costBasis: Decimal
  unrealizedGain: Decimal!
  unrealizedGainPercent: Decimal!
  isoCurrencyCode: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetAllocation {
  type: String!
  value: Decimal!
  percentage: Float!
  color: String!
}

type PortfolioAccount {
  id: ID!
  name: String!
  institution: String!
  value: Decimal!
  holdingCount: Int!
}

type Portfolio {
  totalValue: Decimal!
  totalCostBasis: Decimal!
  totalGain: Decimal!
  totalGainPercent: Float!
  holdingCount: Int!
  accountCount: Int!
  accounts: [PortfolioAccount!]!
}

input AddHoldingInput {
  accountId: String!
  securityName: String!
  tickerSymbol: String
  securityType: String!
  quantity: Float!
  price: Float!
  costBasis: Float
}

input UpdateHoldingPriceInput {
  holdingId: String!
  newPrice: Float!
}

extend type Query {
  portfolio: Portfolio!
  assetAllocation: [AssetAllocation!]!
  holdings(accountId: ID): [InvestmentHolding!]!
}

extend type Mutation {
  addHolding(input: AddHoldingInput!): InvestmentHolding!
  updateHoldingPrice(input: UpdateHoldingPriceInput!): InvestmentHolding!
}
```

Note: `unrealizedGain` and `unrealizedGainPercent` on InvestmentHolding are computed fields resolved in the resolver, not stored in the database.
  </action>
  <verify>Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` and confirm no TypeScript errors in the new file.</verify>
  <done>investment.ts typeDefs file exists with all types, queries, and mutations defined.</done>
</task>

<task type="auto">
  <name>Task 2: Create investment resolvers and register in schema</name>
  <files>
    spendwise-api/src/schema/resolvers/investment.ts
    spendwise-api/src/schema/typeDefs/index.ts
    spendwise-api/src/schema/resolvers/index.ts
  </files>
  <action>
**Create `spendwise-api/src/schema/resolvers/investment.ts`** following the exact pattern from `netWorth.ts`:

Import Context, requireAuth, getCache/setCache/invalidateCache, parseDecimal from their existing locations.

Export `investmentResolvers` object with:

**Query.portfolio:**
- `requireAuth(context)` to get user
- Check Redis cache with key `user:${user.id}:portfolio`
- Query all INVESTMENT accounts: `context.prisma.account.findMany({ where: { userId: user.id, type: 'INVESTMENT' }, include: { holdings: { include: { security: true } } } })`
- Aggregate: totalValue (sum institutionValue), totalCostBasis (sum costBasis where not null), holdingCount, accountCount
- Calculate totalGain = totalValue - totalCostBasis, totalGainPercent = totalCostBasis > 0 ? (totalGain / totalCostBasis) * 100 : 0
- Build accounts array: each with id, name, institution, value (sum of holdings), holdingCount
- Cache result for 900 seconds (15 min)
- Return Portfolio object

**Query.assetAllocation:**
- `requireAuth(context)` to get user
- Check Redis cache with key `user:${user.id}:assetAllocation`
- Fetch all holdings across INVESTMENT accounts with security included
- Normalize security types using a mapping function:
  ```typescript
  function normalizeSecurityType(type: string): string {
    const normalized = type.toLowerCase().trim();
    const typeMap: Record<string, string> = {
      'stock': 'equity', 'stocks': 'equity', 'equities': 'equity',
      'etf': 'etf', 'etfs': 'etf',
      'mutual fund': 'mutual fund', 'mutual funds': 'mutual fund',
      'bond': 'bond', 'bonds': 'bond', 'fixed income': 'bond',
      'cash': 'cash', 'money market': 'cash',
    };
    return typeMap[normalized] || normalized;
  }
  ```
- Format display names: equity->"Stocks", etf->"ETFs", mutual fund->"Mutual Funds", bond->"Bonds", cash->"Cash", other->capitalize
- Color mapping: equity->#3b82f6 (blue), etf->#10b981 (green), mutual fund->#8b5cf6 (purple), bond->#f59e0b (amber), cash->#6b7280 (gray), default->#94a3b8
- Calculate percentage for each type
- Cache for 900 seconds
- Return AssetAllocation array

**Query.holdings:**
- `requireAuth(context)` to get user
- Accept optional `accountId` argument
- If accountId provided, verify ownership, then query holdings for that account
- If no accountId, query all holdings across all INVESTMENT accounts
- Include security relation
- Return holdings array (sorted by institutionValue descending)

**InvestmentHolding field resolvers:**
- `unrealizedGain(parent)`: currentValue = parseDecimal(parent.institutionValue), costBasis = parent.costBasis ? parseDecimal(parent.costBasis) : null. If costBasis is null, return 0 (can't calculate without cost basis). Otherwise return currentValue - costBasis.
- `unrealizedGainPercent(parent)`: Same null check. If costBasis is null or 0, return 0. Otherwise ((currentValue - costBasis) / costBasis) * 100.
- `security(parent, _, context)`: Return `context.prisma.security.findUnique({ where: { id: parent.securityId } })`
- `account(parent, _, context)`: Return `context.prisma.account.findUnique({ where: { id: parent.accountId } })`

**Mutation.addHolding:**
- `requireAuth(context)` to get user
- Verify account ownership: `context.prisma.account.findFirst({ where: { id: input.accountId, userId: user.id, type: 'INVESTMENT' } })`
- Throw if not found: "Investment account not found"
- Look up or create Security: `context.prisma.security.upsert({ where: { plaidSecurityId: tickerSymbol || securityName }, create: { plaidSecurityId: tickerSymbol || securityName, name: securityName, tickerSymbol, type: securityType }, update: {} })`
- Create holding: `context.prisma.investmentHolding.create({ data: { accountId, securityId: security.id, quantity: input.quantity, institutionPrice: input.price, institutionValue: input.quantity * input.price, costBasis: input.costBasis ? input.costBasis : null }, include: { security: true, account: true } })`
- Invalidate caches: `user:${user.id}:portfolio`, `user:${user.id}:assetAllocation`
- Return created holding

**Mutation.updateHoldingPrice:**
- `requireAuth(context)` to get user
- Find holding and verify ownership through account: find holding, include account, check account.userId === user.id
- Throw if not found: "Holding not found"
- Calculate new institutionValue = quantity * newPrice
- Update holding: `context.prisma.investmentHolding.update({ where: { id: holdingId }, data: { institutionPrice: newPrice, institutionValue: newQuantity * newPrice } })`
- Invalidate caches
- Return updated holding with include: { security: true, account: true }

**Register in index files:**

In `spendwise-api/src/schema/typeDefs/index.ts`:
- Add `import { investmentTypeDefs } from './investment';`
- Add `investmentTypeDefs` to the typeDefs array

In `spendwise-api/src/schema/resolvers/index.ts`:
- Add `import { investmentResolvers } from './investment';`
- Spread `...investmentResolvers.Query` in Query object
- Spread `...investmentResolvers.Mutation` in Mutation object
- Add `InvestmentHolding: investmentResolvers.InvestmentHolding` as a type resolver (like Account, Transaction patterns)
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` â€” no TypeScript errors.
Run `cd /Users/heechung/projects/spendwise-api && npm run dev` briefly and confirm server starts without errors (check for "Server ready" in output). Stop the server after confirming.
  </verify>
  <done>Investment resolvers handle all 3 queries (portfolio, assetAllocation, holdings) and 2 mutations (addHolding, updateHoldingPrice) with Redis caching, proper auth guards, and are registered in the schema indexes.</done>
</task>

</tasks>

<verification>
1. `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` passes with no errors
2. Server starts without crashing: `npm run dev` shows "Server ready"
3. investment.ts typeDefs file exports `investmentTypeDefs`
4. investment.ts resolvers file exports `investmentResolvers` with Query, Mutation, and InvestmentHolding keys
5. Both index files import and register the new investment module
</verification>

<success_criteria>
- GraphQL schema includes Portfolio, InvestmentHolding, Security, AssetAllocation types
- Three queries available: portfolio, assetAllocation, holdings(accountId)
- Two mutations available: addHolding(input), updateHoldingPrice(input)
- All queries filter by INVESTMENT account type and authenticated user
- Redis caching on portfolio and assetAllocation queries
- Unrealized gain computed fields handle null costBasis gracefully
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-investment-portfolio/06-01-SUMMARY.md`
</output>
