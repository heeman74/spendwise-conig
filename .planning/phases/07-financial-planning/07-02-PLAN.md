---
phase: 07-financial-planning
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - spendwise-api/src/schema/typeDefs/financialPlanning.ts
  - spendwise-api/src/schema/resolvers/financialPlanning.ts
  - spendwise-api/src/schema/typeDefs/index.ts
  - spendwise-api/src/schema/resolvers/index.ts
  - spendwise-api/src/routes/chat-stream.ts
  - spendwise-api/src/index.ts
  - spendwise-api/src/schema/resolvers/statementImport.ts
autonomous: true

must_haves:
  truths:
    - "GraphQL queries return chat sessions, messages, active insights, and rate limit status"
    - "GraphQL mutations create/continue chat sessions, send messages, and regenerate insights"
    - "SSE endpoint streams Claude responses token-by-token to authenticated clients"
    - "Insight cache invalidated when new statement is imported"
    - "Chat message includes per-message disclaimer appended automatically"
  artifacts:
    - path: "spendwise-api/src/schema/typeDefs/financialPlanning.ts"
      provides: "GraphQL types for chat sessions, messages, insights, rate limits"
      exports: ["financialPlanningTypeDefs"]
    - path: "spendwise-api/src/schema/resolvers/financialPlanning.ts"
      provides: "Resolvers for all financial planning queries and mutations"
      exports: ["financialPlanningResolvers"]
    - path: "spendwise-api/src/routes/chat-stream.ts"
      provides: "SSE streaming endpoint for chat responses"
      exports: ["chatStreamRouter"]
  key_links:
    - from: "spendwise-api/src/schema/resolvers/financialPlanning.ts"
      to: "spendwise-api/src/services/financialPlanning/*"
      via: "imports all services from Plan 01"
      pattern: "import.*financialPlanning"
    - from: "spendwise-api/src/routes/chat-stream.ts"
      to: "spendwise-api/src/services/financialPlanning/claude-client.ts"
      via: "streams Claude responses via SSE"
      pattern: "streamChatResponse"
    - from: "spendwise-api/src/schema/typeDefs/index.ts"
      to: "spendwise-api/src/schema/typeDefs/financialPlanning.ts"
      via: "added to typeDefs array"
      pattern: "financialPlanningTypeDefs"
---

<objective>
Create the GraphQL API layer and SSE streaming endpoint for financial planning. This includes type definitions, resolvers for chat sessions/messages/insights, an Express SSE route for streaming Claude responses, and insight invalidation on statement import.

Purpose: Exposes Plan 01's services through the GraphQL API and provides a streaming endpoint for real-time chat responses. This is the API contract the frontend will consume.

Output: GraphQL types/resolvers for financial planning, SSE streaming route, and import-triggered insight invalidation.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-financial-planning/07-RESEARCH.md
@.planning/phases/07-financial-planning/07-CONTEXT.md
@.planning/phases/07-financial-planning/07-01-SUMMARY.md

Key existing patterns:
@spendwise-api/src/schema/typeDefs/index.ts (how to register new typeDefs)
@spendwise-api/src/schema/resolvers/index.ts (how to register new resolvers)
@spendwise-api/src/schema/typeDefs/investment.ts (recent typeDef pattern)
@spendwise-api/src/schema/resolvers/investment.ts (recent resolver pattern)
@spendwise-api/src/schema/resolvers/statementImport.ts (where to add insight invalidation)
@spendwise-api/src/index.ts (Express app setup for adding SSE route)
@spendwise-api/src/context/auth.ts (JWT auth for SSE endpoint)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphQL typeDefs and resolvers for financial planning</name>
  <files>
    spendwise-api/src/schema/typeDefs/financialPlanning.ts
    spendwise-api/src/schema/resolvers/financialPlanning.ts
    spendwise-api/src/schema/typeDefs/index.ts
    spendwise-api/src/schema/resolvers/index.ts
  </files>
  <action>
**Create `src/schema/typeDefs/financialPlanning.ts`:**

Define GraphQL types using `extend type Query` and `extend type Mutation` pattern (same as recurring.ts, investment.ts):

Types:
- `ChatSession { id, title, createdAt, updatedAt, messages: [ChatMessage!]! }`
- `ChatMessage { id, sessionId, role, content, metadata: JSON, createdAt }`
- `InsightCard { id, insightType, title, content, priority, generatedAt }`
- `RateLimitStatus { allowed: Boolean!, remaining: Int!, resetAt: String! }`
- `SendMessageResult { success: Boolean!, sessionId: String!, messageId: String! }`
- `GoalParseResult { parsed: Boolean!, goal: SavingsGoal, confidence: Int }`

Queries:
- `chatSessions: [ChatSession!]!` - List user's chat sessions (ordered by updatedAt desc)
- `chatSession(id: String!): ChatSession` - Get single session with messages
- `activeInsights: [InsightCard!]!` - Get current non-invalidated insights (up to 5)
- `chatRateLimit: RateLimitStatus!` - Check remaining daily messages

Mutations:
- `createChatSession(title: String): ChatSession!` - Start new chat session
- `sendChatMessage(sessionId: String!, content: String!): SendMessageResult!` - Save user message, check rate limit, increment usage. Does NOT generate AI response (SSE handles that).
- `regenerateInsights: [InsightCard!]!` - Force regenerate insights
- `parseGoalFromChat(input: String!, sessionId: String): GoalParseResult!` - Parse freeform goal text, create SavingsGoal if confident

**Create `src/schema/resolvers/financialPlanning.ts`:**

Export `financialPlanningResolvers` with Query and Mutation objects.

Query resolvers:
- `chatSessions`: requireAuth, query ChatSession where userId, orderBy updatedAt desc, include messages (limit last 1 for preview)
- `chatSession`: requireAuth, query ChatSession where id AND userId (security!), include messages orderBy createdAt asc
- `activeInsights`: requireAuth, call getActiveInsights from insight-generator service. If no insights exist and user has 2+ months of data, trigger generateAndCacheInsights.
- `chatRateLimit`: requireAuth, call checkRateLimit from rate-limiter service

Mutation resolvers:
- `createChatSession`: requireAuth, create ChatSession with userId and optional title
- `sendChatMessage`: requireAuth, check rate limit (throw error if exceeded), verify session belongs to user, save user ChatMessage, increment usage, return { success: true, sessionId, messageId }
- `regenerateInsights`: requireAuth, call generateAndCacheInsights, return new insights
- `parseGoalFromChat`: requireAuth, call parseAndCreateGoal from goal-parser, return result with confidence

IMPORTANT: Every assistant message saved to DB must have the disclaimer appended. The SSE endpoint handles this when saving the complete response.

**Register in index files:**
- Add `import { financialPlanningTypeDefs } from './financialPlanning'` to typeDefs/index.ts and add to array
- Add `import { financialPlanningResolvers } from './financialPlanning'` to resolvers/index.ts and spread into Query and Mutation objects
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` passes.
Verify financialPlanningTypeDefs is in the typeDefs array in index.ts.
Verify financialPlanningResolvers is spread into Query and Mutation in resolvers/index.ts.
  </verify>
  <done>
GraphQL API for financial planning is complete: 4 queries (chatSessions, chatSession, activeInsights, chatRateLimit) and 4 mutations (createChatSession, sendChatMessage, regenerateInsights, parseGoalFromChat) are registered and compilable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SSE streaming endpoint and insight invalidation trigger</name>
  <files>
    spendwise-api/src/routes/chat-stream.ts
    spendwise-api/src/index.ts
    spendwise-api/src/schema/resolvers/statementImport.ts
  </files>
  <action>
**Create `src/routes/chat-stream.ts`** - Express router for SSE streaming:

Create an Express Router with a POST route at `/api/chat/stream`:
1. Extract Authorization header, validate JWT token using the same `getUserFromToken` function from `../../context/auth.ts`
2. If no valid user, return 401
3. Extract `sessionId` and `content` from request body (JSON)
4. Check rate limit via checkRateLimit - if exceeded, return 429 with JSON error
5. Verify session belongs to user via prisma.chatSession.findFirst({ where: { id: sessionId, userId } })
6. If session not found, return 404
7. Save user message to ChatMessage table
8. Increment rate limit usage
9. Build financial summary via buildFinancialSummary
10. Load conversation history: query ChatMessage where sessionId, orderBy createdAt asc, take last 20 messages
11. Set SSE headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`, `X-Accel-Buffering: no`
12. Start streaming via streamChatResponse generator
13. For each yielded chunk:
    - If type is 'text_chunk': write `data: ${JSON.stringify({ type: 'chunk', content: chunk.content })}\n\n`
    - If type is 'done': Append disclaimer to content. Save complete assistant message to ChatMessage table with metadata (model, tokens). Write `data: ${JSON.stringify({ type: 'done', messageId })}\n\n`. Close response.
14. On stream error: write `data: ${JSON.stringify({ type: 'error', message: 'Failed to generate response' })}\n\n`. Close response. Log error.
15. Handle client disconnect: `req.on('close', () => { /* cleanup */ })`

Export the router as `chatStreamRouter`.

**Register in `src/index.ts`:**
- Import chatStreamRouter from './routes/chat-stream'
- Add `app.use(express.json())` middleware if not already present (check - it should be)
- Mount: `app.use('/api/chat', chatStreamRouter)` BEFORE the Apollo Server middleware
- Ensure CORS is applied to this route (same origins as /graphql)

**Add insight invalidation in `src/schema/resolvers/statementImport.ts`:**
Find the statement import completion mutation (where status is set to COMPLETED). After successful import, add:
```typescript
// Invalidate cached insights so they regenerate with new data
try {
  await context.prisma.insightCache.updateMany({
    where: { userId: user.id, invalidatedAt: null },
    data: { invalidatedAt: new Date() },
  });
} catch (e) {
  console.error('Failed to invalidate insight cache:', e);
  // Non-blocking: don't fail import
}
```
This ensures insights are regenerated after new statement data arrives.
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` passes.
Verify chatStreamRouter is mounted in index.ts.
Verify statementImport resolver includes insightCache invalidation.
  </verify>
  <done>
SSE streaming endpoint at POST /api/chat/stream handles authenticated streaming chat with Claude. Responses stream token-by-token with proper SSE formatting. Complete responses are persisted with disclaimer. Insight cache is invalidated on statement import completion.
  </done>
</task>

</tasks>

<verification>
1. `cd spendwise-api && npx tsc --noEmit` passes
2. GraphQL schema includes ChatSession, ChatMessage, InsightCard, RateLimitStatus types
3. SSE endpoint registered at /api/chat/stream
4. Statement import invalidates InsightCache
5. All resolvers require authentication
</verification>

<success_criteria>
- 4 queries + 4 mutations registered in GraphQL schema
- SSE endpoint streams Claude responses with proper event format
- Assistant messages include disclaimer before persistence
- Insight cache invalidated after statement import
- Rate limit enforced on both GraphQL mutation and SSE endpoint
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-financial-planning/07-02-SUMMARY.md`
</output>
