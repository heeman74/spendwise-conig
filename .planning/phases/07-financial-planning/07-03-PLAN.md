---
phase: 07-financial-planning
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - spendwise/src/graphql/queries/financialPlanning.ts
  - spendwise/src/graphql/mutations/financialPlanning.ts
  - spendwise/src/graphql/queries/index.ts
  - spendwise/src/graphql/mutations/index.ts
  - spendwise/src/hooks/useFinancialPlanning.ts
  - spendwise/src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can query chat sessions, messages, insights, and rate limit status via Apollo hooks"
    - "Frontend can create sessions, send messages, regenerate insights, and parse goals via mutation hooks"
    - "SSE streaming client connects to /api/chat/stream and yields tokens incrementally"
    - "All hooks follow established options-object pattern with cache-and-network fetch policy"
  artifacts:
    - path: "spendwise/src/graphql/queries/financialPlanning.ts"
      provides: "GraphQL query documents for financial planning"
      exports: ["GET_CHAT_SESSIONS", "GET_CHAT_SESSION", "GET_ACTIVE_INSIGHTS", "GET_CHAT_RATE_LIMIT"]
    - path: "spendwise/src/graphql/mutations/financialPlanning.ts"
      provides: "GraphQL mutation documents for financial planning"
      exports: ["CREATE_CHAT_SESSION", "SEND_CHAT_MESSAGE", "REGENERATE_INSIGHTS", "PARSE_GOAL_FROM_CHAT"]
    - path: "spendwise/src/hooks/useFinancialPlanning.ts"
      provides: "React hooks for financial planning data and mutations"
      exports: ["useChatSessions", "useChatSession", "useActiveInsights", "useChatRateLimit", "useCreateChatSession", "useSendChatMessage", "useRegenerateInsights", "useParseGoalFromChat", "useChatStream"]
  key_links:
    - from: "spendwise/src/hooks/useFinancialPlanning.ts"
      to: "spendwise/src/graphql/queries/financialPlanning.ts"
      via: "Apollo useQuery hooks"
      pattern: "useQuery.*GET_CHAT"
    - from: "spendwise/src/hooks/useFinancialPlanning.ts"
      to: "/api/chat/stream"
      via: "SSE fetch client for streaming"
      pattern: "EventSource\\|fetch.*chat/stream"
---

<objective>
Build the frontend data layer: GraphQL query/mutation documents and React hooks for all financial planning operations, plus an SSE streaming client for real-time chat responses.

Purpose: Connects the frontend to the Plan 02 API. All UI components in Plan 04 will consume these hooks exclusively.

Output: GraphQL documents, Apollo hooks, SSE streaming hook, all registered in barrel exports.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-financial-planning/07-02-SUMMARY.md

Key existing patterns:
@spendwise/src/graphql/queries/portfolio.ts (recent query pattern)
@spendwise/src/graphql/mutations/portfolio.ts (recent mutation pattern)
@spendwise/src/hooks/usePortfolio.ts (recent hooks pattern)
@spendwise/src/hooks/useRecurring.ts (mutation hooks with refetchQueries)
@spendwise/src/graphql/queries/index.ts (barrel export)
@spendwise/src/graphql/mutations/index.ts (barrel export)
@spendwise/src/hooks/index.ts (barrel export)
@spendwise/src/lib/apollo-client.ts (Apollo client config, auth link)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GraphQL query and mutation documents for financial planning</name>
  <files>
    spendwise/src/graphql/queries/financialPlanning.ts
    spendwise/src/graphql/mutations/financialPlanning.ts
    spendwise/src/graphql/queries/index.ts
    spendwise/src/graphql/mutations/index.ts
  </files>
  <action>
**Create `src/graphql/queries/financialPlanning.ts`:**

Use `gql` from `@apollo/client` (same pattern as portfolio.ts).

```
GET_CHAT_SESSIONS - query chatSessions { id, title, createdAt, updatedAt, messages { id, content, createdAt } }
(messages limited to last 1 for preview)

GET_CHAT_SESSION - query chatSession($id: String!) { id, title, createdAt, updatedAt, messages { id, sessionId, role, content, metadata, createdAt } }

GET_ACTIVE_INSIGHTS - query activeInsights { id, insightType, title, content, priority, generatedAt }

GET_CHAT_RATE_LIMIT - query chatRateLimit { allowed, remaining, resetAt }
```

**Create `src/graphql/mutations/financialPlanning.ts`:**

```
CREATE_CHAT_SESSION - mutation createChatSession($title: String) { id, title, createdAt }

SEND_CHAT_MESSAGE - mutation sendChatMessage($sessionId: String!, $content: String!) { success, sessionId, messageId }

REGENERATE_INSIGHTS - mutation regenerateInsights { id, insightType, title, content, priority, generatedAt }

PARSE_GOAL_FROM_CHAT - mutation parseGoalFromChat($input: String!, $sessionId: String) { parsed, goal { id, name, targetAmount, currentAmount, deadline }, confidence }
```

**Update barrel exports:**
- Add `export * from './financialPlanning'` to `src/graphql/queries/index.ts`
- Add `export * from './financialPlanning'` to `src/graphql/mutations/index.ts`
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise && npx tsc --noEmit` passes (or at minimum, the GraphQL documents export correctly).
Verify barrel exports include financialPlanning.
  </verify>
  <done>
4 query documents and 4 mutation documents exported for financial planning. All registered in barrel exports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React hooks and SSE streaming client for financial planning</name>
  <files>
    spendwise/src/hooks/useFinancialPlanning.ts
    spendwise/src/hooks/index.ts
  </files>
  <action>
**Create `src/hooks/useFinancialPlanning.ts`:**

Follow established hook patterns (usePortfolio.ts, useRecurring.ts). Mark with `'use client'` directive.

**Query hooks:**

`useChatSessions()` - useQuery(GET_CHAT_SESSIONS) with fetchPolicy: 'cache-and-network'. Return { sessions, loading, error, refetch }.

`useChatSession(sessionId: string | null)` - useQuery(GET_CHAT_SESSION, { variables: { id: sessionId }, skip: !sessionId, fetchPolicy: 'cache-and-network' }). Return { session, messages, loading, error, refetch }.

`useActiveInsights()` - useQuery(GET_ACTIVE_INSIGHTS) with fetchPolicy: 'cache-and-network'. Return { insights, loading, error, refetch }.

`useChatRateLimit()` - useQuery(GET_CHAT_RATE_LIMIT) with fetchPolicy: 'network-only' (always fresh). Return { rateLimit, loading }.

**Mutation hooks:**

`useCreateChatSession()` - useMutation(CREATE_CHAT_SESSION, { refetchQueries: [{ query: GET_CHAT_SESSIONS }] }). Return { createSession, loading, error }.

`useSendChatMessage()` - useMutation(SEND_CHAT_MESSAGE). Return { sendMessage, loading, error }. No refetchQueries needed since SSE handles the assistant response and we'll manually update the cache.

`useRegenerateInsights()` - useMutation(REGENERATE_INSIGHTS, { refetchQueries: [{ query: GET_ACTIVE_INSIGHTS }] }). Return { regenerateInsights, loading, error }.

`useParseGoalFromChat()` - useMutation(PARSE_GOAL_FROM_CHAT). Return { parseGoal, loading, error }.

**SSE Streaming hook:**

`useChatStream()` - Custom hook for SSE streaming. NOT an Apollo hook.

```typescript
export function useChatStream() {
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamedContent, setStreamedContent] = useState('');
  const [error, setError] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const startStream = useCallback(async (
    sessionId: string,
    content: string,
    onChunk?: (text: string) => void,
    onDone?: (fullContent: string, messageId: string) => void,
    onError?: (error: string) => void
  ) => {
    setIsStreaming(true);
    setStreamedContent('');
    setError(null);

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    try {
      // Get auth token from session
      const session = await fetch('/api/auth/session');
      const sessionData = await session.json();
      const token = sessionData?.accessToken;

      const response = await fetch(
        `${process.env.NEXT_PUBLIC_GRAPHQL_URL?.replace('/graphql', '')}/api/chat/stream`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
          },
          body: JSON.stringify({ sessionId, content }),
          signal: abortController.signal,
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Stream request failed');
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let accumulated = '';

      if (!reader) throw new Error('No response body');

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const text = decoder.decode(value, { stream: true });
        const lines = text.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (data.type === 'chunk') {
                accumulated += data.content;
                setStreamedContent(accumulated);
                onChunk?.(data.content);
              } else if (data.type === 'done') {
                onDone?.(accumulated, data.messageId);
              } else if (data.type === 'error') {
                setError(data.message);
                onError?.(data.message);
              }
            } catch { /* ignore parse errors for incomplete chunks */ }
          }
        }
      }
    } catch (err: any) {
      if (err.name !== 'AbortError') {
        const msg = err.message || 'Stream failed';
        setError(msg);
        onError?.(msg);
      }
    } finally {
      setIsStreaming(false);
      abortControllerRef.current = null;
    }
  }, []);

  const stopStream = useCallback(() => {
    abortControllerRef.current?.abort();
  }, []);

  return { startStream, stopStream, isStreaming, streamedContent, error };
}
```

**Update barrel export:**
Add `export * from './useFinancialPlanning'` to `src/hooks/index.ts`.
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise && npx tsc --noEmit` passes.
Verify useFinancialPlanning is exported from hooks/index.ts.
Verify all 9 hooks are exported (4 query, 4 mutation, 1 streaming).
  </verify>
  <done>
9 hooks exported for financial planning: 4 query hooks (sessions, session, insights, rate limit), 4 mutation hooks (create session, send message, regenerate insights, parse goal), 1 SSE streaming hook (useChatStream with start/stop/content/error). All registered in barrel export. All follow established project patterns.
  </done>
</task>

</tasks>

<verification>
1. `cd spendwise && npx tsc --noEmit` passes
2. 4 query documents exported from graphql/queries/financialPlanning.ts
3. 4 mutation documents exported from graphql/mutations/financialPlanning.ts
4. 9 hooks exported from hooks/useFinancialPlanning.ts
5. All barrel exports updated
</verification>

<success_criteria>
- Frontend data layer complete: queries, mutations, hooks for all financial planning operations
- SSE streaming client connects to backend, parses event stream, yields chunks to consumers
- Hooks follow cache-and-network pattern consistent with prior phases
- Document-based refetchQueries used (Phase 4 decision)
- All exports registered in barrel files
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-financial-planning/07-03-SUMMARY.md`
</output>
