---
phase: 03-spending-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spendwise-api/src/schema/typeDefs/analytics.ts
  - spendwise-api/src/schema/resolvers/analytics.ts
  - spendwise-api/src/schema/resolvers/index.ts
  - spendwise/prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "analytics query accepts optional dateRange and accountIds filter parameters"
    - "trends field returns multi-month time series data (6 months), not single data point"
    - "topMerchants query returns merchants sorted by total spending with transaction count and average"
    - "All existing analytics queries continue to work without filter parameters (backward compatible)"
  artifacts:
    - path: "spendwise-api/src/schema/typeDefs/analytics.ts"
      provides: "DateRangeInput, MerchantStats types, extended query signatures"
      contains: "DateRangeInput"
    - path: "spendwise-api/src/schema/resolvers/analytics.ts"
      provides: "Filter-aware analytics resolver, multi-month trends, topMerchants resolver"
      exports: ["analyticsResolvers"]
  key_links:
    - from: "spendwise-api/src/schema/typeDefs/analytics.ts"
      to: "spendwise-api/src/schema/resolvers/analytics.ts"
      via: "GraphQL schema/resolver mapping"
      pattern: "topMerchants.*dateRange.*accountIds"
    - from: "spendwise-api/src/schema/resolvers/analytics.ts"
      to: "prisma.transaction"
      via: "Prisma queries with conditional where clauses"
      pattern: "dateRange.*gte.*lte"
---

<objective>
Extend the analytics GraphQL API to support date range filtering, account filtering, multi-month trend data, and top merchants query.

Purpose: The existing analytics resolver only accepts a period enum and returns single-point trend data with no filtering. Phase 3 requires date range + account filters across all analytics, real multi-month trends for the line chart, and a new topMerchants query for merchant spending analysis.

Output: Enhanced analytics resolver and typeDefs that power the entire spending analysis frontend.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-spending-analysis/03-RESEARCH.md
@spendwise-api/src/schema/typeDefs/analytics.ts
@spendwise-api/src/schema/typeDefs/common.ts
@spendwise-api/src/schema/typeDefs/index.ts
@spendwise-api/src/schema/resolvers/analytics.ts
@spendwise-api/src/schema/resolvers/index.ts
@spendwise-api/src/lib/utils.ts
@spendwise/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GraphQL schema with filter inputs and merchant types</name>
  <files>spendwise-api/src/schema/typeDefs/analytics.ts</files>
  <action>
  Add the following to the analytics typeDefs:

  1. Add `DateRangeInput` input type with `start: DateTime!` and `end: DateTime!` fields.

  2. Add `MerchantStats` type with fields:
     - `merchant: String!`
     - `totalAmount: Decimal!`
     - `transactionCount: Int!`
     - `averageAmount: Decimal!`
     - `categoryBreakdown: [CategoryAmount!]!`

  3. Update the `analytics` query signature to accept optional `dateRange: DateRangeInput` and `accountIds: [ID!]` parameters (keep existing `period` parameter with default).

  4. Update the `spendingByCategory` query to accept optional `dateRange: DateRangeInput` and `accountIds: [ID!]` parameters.

  5. Add new `topMerchants` query:
     ```
     topMerchants(dateRange: DateRangeInput, accountIds: [ID!], limit: Int = 10): [MerchantStats!]!
     ```

  Keep ALL existing types (Analytics, DateRange, FinancialSummary, CategoryAmount, TrendData, PeriodComparison, DashboardStats) unchanged. Only extend query signatures and add new types.
  </action>
  <verify>Run `cd /Users/heechung/projects/spendwise-api && npm run build` to confirm TypeScript compiles (typeDefs are just strings, so this validates syntax). Visually inspect the file to confirm DateRangeInput, MerchantStats, and updated query signatures exist.</verify>
  <done>analytics typeDefs include DateRangeInput input, MerchantStats type, and all three queries (analytics, spendingByCategory, topMerchants) accept optional dateRange and accountIds parameters.</done>
</task>

<task type="auto">
  <name>Task 2: Implement filter-aware resolvers with multi-month trends and topMerchants</name>
  <files>
    spendwise-api/src/schema/resolvers/analytics.ts
    spendwise-api/src/schema/resolvers/index.ts
  </files>
  <action>
  Modify the analytics resolver in `spendwise-api/src/schema/resolvers/analytics.ts`:

  1. **Update `analytics` resolver** to accept `{ period, dateRange, accountIds }` args:
     - If `dateRange` is provided, use it directly instead of computing from `period`.
     - If `accountIds` is provided (non-empty array), add `accountId: { in: accountIds }` to all where clauses.
     - Update cache key to include dateRange and accountIds: `user:${user.id}:analytics:${period}:${dateRange?.start?.toISOString() || ''}:${dateRange?.end?.toISOString() || ''}:${accountIds?.sort().join(',') || ''}`.

  2. **Replace the simplified trends calculation** with actual multi-month trend data:
     - Fetch transactions for the last 6 months (or within dateRange if provided).
     - Group by month using the transaction `date` field: `const monthKey = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0')`.
     - For each month, sum income (type === 'INCOME') and expenses (type === 'EXPENSE').
     - Calculate savings = income - expenses for each month.
     - Return `{ labels: ['Jan 2026', 'Feb 2026', ...], income: [...], expenses: [...], savings: [...] }`.
     - Use month name + year format for labels (e.g., "Jan 2026").
     - Sort labels chronologically.
     - If dateRange provided, use its boundaries for the trend window. If only period, compute 6-month window ending at current period end.

  3. **Update `spendingByCategory` resolver** to accept `{ period, dateRange, accountIds }`:
     - Same pattern: use dateRange if provided, else compute from period.
     - Add accountIds filter if provided.

  4. **Add `topMerchants` resolver**:
     - Accept `{ dateRange, accountIds, limit = 10 }`.
     - Default date range: current month if not provided.
     - Query transactions: `{ userId, type: 'EXPENSE', merchant: { not: null } }` plus date/account filters.
     - Aggregate by merchant using reduce: for each merchant, track totalAmount, transactionCount, and per-category amounts.
     - Calculate averageAmount = totalAmount / transactionCount.
     - Build categoryBreakdown array with category, amount, percentage (relative to that merchant's total), and color from getCategoryColor.
     - Sort by totalAmount descending, slice to limit.
     - Cache for 15 minutes with key including filters.

  5. **Register topMerchants** in the Query object of analyticsResolvers (it's already in the same file's Query object).

  6. In `spendwise-api/src/schema/resolvers/index.ts`, no changes needed if topMerchants is added to analyticsResolvers.Query (it's already spread). Verify this is the case.

  Important implementation notes:
  - Use `parseDecimal()` from `../../lib/utils` for all Decimal conversions (existing pattern).
  - Handle division by zero in percentage calculations (check total > 0 before dividing).
  - The `getDateRange(period)` helper returns `{ start, end }` -- use it as fallback when no dateRange arg.
  - For trend data months, handle the case where a month has no transactions (return 0 for income/expenses/savings).
  - Keep existing `dashboardStats` resolver untouched.
  </action>
  <verify>
  Run `cd /Users/heechung/projects/spendwise-api && npm run build` to confirm TypeScript compiles.
  Run `cd /Users/heechung/projects/spendwise-api && npm test` to confirm existing tests pass.
  </verify>
  <done>
  - analytics query returns multi-month trend data (6 months of labels/income/expenses/savings arrays)
  - analytics and spendingByCategory accept optional dateRange and accountIds, falling back to period-based behavior when not provided
  - topMerchants query returns merchants with totalAmount, transactionCount, averageAmount, and categoryBreakdown
  - All existing behavior preserved when no filter args passed
  </done>
</task>

<task type="auto">
  <name>Task 3: Add composite database index for query performance</name>
  <files>spendwise/prisma/schema.prisma</files>
  <action>
  Add a composite index on the Transaction model for the analytics query pattern:

  ```prisma
  @@index([userId, date, type])
  ```

  This index supports the most common analytics query pattern: filter by userId first, then date range, then type (EXPENSE vs INCOME). The individual indexes on userId, date, and category already exist but the composite index prevents sequential scans on large datasets.

  Add it after the existing `@@index` entries on the Transaction model.

  Then run:
  ```bash
  cd /Users/heechung/projects/spendwise && npx prisma db push
  ```
  to apply the index.

  Also run `cd /Users/heechung/projects/spendwise && npx prisma generate` to regenerate the client.
  </action>
  <verify>Run `cd /Users/heechung/projects/spendwise && npx prisma db push` completes without error. Run `cd /Users/heechung/projects/spendwise && npx prisma generate` completes without error.</verify>
  <done>Composite index [userId, date, type] exists on Transaction model, applied to database.</done>
</task>

</tasks>

<verification>
1. `cd /Users/heechung/projects/spendwise-api && npm run build` -- TypeScript compiles
2. `cd /Users/heechung/projects/spendwise-api && npm test` -- existing tests pass
3. `cd /Users/heechung/projects/spendwise && npx prisma db push` -- schema applied
4. Verify `topMerchants` is accessible in the GraphQL schema by checking resolver index spreads analyticsResolvers.Query
</verification>

<success_criteria>
- GraphQL schema has DateRangeInput, MerchantStats types
- analytics, spendingByCategory queries accept dateRange + accountIds
- topMerchants query exists and returns merchant aggregation
- Trend data returns multi-month arrays (not single "Current Period" point)
- Backward compatible: queries without filter args work as before
- Composite index applied to database
</success_criteria>

<output>
After completion, create `.planning/phases/03-spending-analysis/03-01-SUMMARY.md`
</output>
