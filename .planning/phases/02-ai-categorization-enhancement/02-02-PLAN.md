---
phase: 02-ai-categorization-enhancement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - spendwise-api/src/lib/ai/categorizer.ts
  - spendwise-api/src/lib/merchant-rules.ts
  - spendwise-api/src/schema/resolvers/transaction.ts
autonomous: true

must_haves:
  truths:
    - "AI uses the user's past manual corrections to inform future categorizations"
    - "When a user corrects a transaction category, similar past transactions are retroactively updated"
    - "Retroactive updates never overwrite manually-categorized transactions"
    - "The updateTransaction mutation returns the count of retroactively updated transactions"
  artifacts:
    - path: "spendwise-api/src/lib/ai/categorizer.ts"
      provides: "User history context in AI prompt"
      contains: "groupBy"
    - path: "spendwise-api/src/lib/merchant-rules.ts"
      provides: "Retroactive re-categorization function"
      contains: "applyMerchantRuleRetroactively"
    - path: "spendwise-api/src/schema/resolvers/transaction.ts"
      provides: "Enhanced updateTransaction calling retroactive update"
      contains: "applyMerchantRuleRetroactively"
  key_links:
    - from: "spendwise-api/src/lib/ai/categorizer.ts"
      to: "prisma.transaction.groupBy"
      via: "User history query for prompt context"
      pattern: "groupBy.*categorySource.*manual"
    - from: "spendwise-api/src/schema/resolvers/transaction.ts"
      to: "spendwise-api/src/lib/merchant-rules.ts"
      via: "Calls applyMerchantRuleRetroactively after rule creation"
      pattern: "applyMerchantRuleRetroactively"
    - from: "spendwise-api/src/lib/merchant-rules.ts"
      to: "prisma.transaction.updateMany"
      via: "Retroactive bulk update"
      pattern: "updateMany.*categorySource.*notIn.*manual"
---

<objective>
Add user history context to the AI categorization prompt and implement retroactive re-categorization when merchant rules change.

Purpose: This is the "learning" brain of the categorization system. Without user history, the AI categorizes generically. With it, the AI mirrors the user's personal preferences. Without retroactive re-categorization, a user must manually fix every past transaction individually. With it, one correction fixes all similar transactions.

Output: Enhanced categorizer with user history in prompt, retroactive re-categorization function, updated transaction resolver.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/heechung/projects/.planning/PROJECT.md
@/Users/heechung/projects/.planning/ROADMAP.md
@/Users/heechung/projects/.planning/phases/02-ai-categorization-enhancement/02-RESEARCH.md

Key source files to read before implementing:
@/Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts
@/Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts
@/Users/heechung/projects/spendwise-api/src/schema/resolvers/transaction.ts
@/Users/heechung/projects/spendwise-api/src/lib/parsers/merchant-cleaner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user history context to AI categorization prompt</name>
  <files>
    spendwise-api/src/lib/ai/categorizer.ts
  </files>
  <action>
    Enhance the `categorizeTransactionsAI` function to query the user's past categorization patterns and include them in the AI system prompt.

    1. Add a new helper function `getUserCategoryHistory` (can be in the same file or as a private function):
       ```typescript
       async function getUserCategoryHistory(
         prisma: any,
         userId: string
       ): Promise<string> {
         try {
           const recentPatterns = await prisma.transaction.groupBy({
             by: ['merchant', 'category'],
             where: {
               userId,
               categorySource: { in: ['manual', 'rule'] },
               merchant: { not: null },
             },
             _count: { id: true },
             orderBy: { _count: { id: 'desc' } },
             take: 50,
           });

           if (recentPatterns.length === 0) return '';

           const lines = recentPatterns
             .map((p: any) => `${p.merchant} -> ${p.category} (${p._count.id}x)`)
             .join('\n');

           return `\n\nThis user has previously categorized these merchants:\n${lines}\n\nUse these as strong signals. Match similar merchants to the same categories.`;
         } catch (error) {
           console.error('Failed to fetch user category history:', error);
           return '';
         }
       }
       ```

    2. In the `categorizeTransactionsAI` function, BEFORE the OpenAI batch loop (before `for (let batchStart = 0; ...)`), call:
       ```typescript
       const userHistoryContext = await getUserCategoryHistory(prisma, userId);
       ```

    3. Append `userHistoryContext` to the system prompt content. The system prompt already has the base instructions. Simply concatenate:
       ```typescript
       content: `You are a financial transaction categorizer. ...existing prompt text...${userHistoryContext}`,
       ```

    IMPORTANT:
    - The user history query is called ONCE before the batch loop, not per-batch.
    - The `try/catch` in `getUserCategoryHistory` ensures AI categorization works even if the history query fails.
    - Only transactions with `categorySource: 'manual'` or `'rule'` are included (these represent deliberate user choices).
    - Limited to top 50 to avoid prompt token bloat (~500 tokens).
    - The `merchant` field is filtered `{ not: null }` to skip transactions without merchants.

    NOTE ON CONCURRENCY WITH PLAN 01: Plan 01 also modifies categorizer.ts (Structured Outputs upgrade). If Plan 01 runs first, you'll see the zodResponseFormat code. If this plan runs first, Plan 01 will see the user history code. Either way, the changes are to different sections of the file and should merge cleanly:
    - Plan 01 changes: imports, Zod schema definition, and the OpenAI call section (Step 4)
    - Plan 02 changes: new helper function (getUserCategoryHistory) and a one-line addition to the system prompt

    If you see the file already has Structured Outputs changes from Plan 01, work with them. If it still has JSON mode, work with that. The user history enhancement is independent of the response format.
  </action>
  <verify>
    - `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` compiles without errors
    - `grep "getUserCategoryHistory" /Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts` returns a match
    - `grep "groupBy" /Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts` returns a match
    - `grep "categorySource.*manual" /Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts` returns a match
    - `grep "userHistoryContext" /Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts` returns a match
  </verify>
  <done>
    - AI categorizer queries user's top 50 manually-corrected merchant-category pairs
    - User history is appended to the system prompt
    - History query failure does not break categorization (graceful degradation)
    - Prompt token usage stays reasonable (top 50 limit)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement retroactive re-categorization on merchant rule changes</name>
  <files>
    spendwise-api/src/lib/merchant-rules.ts
    spendwise-api/src/schema/resolvers/transaction.ts
  </files>
  <action>
    1. Add retroactive re-categorization function to `spendwise-api/src/lib/merchant-rules.ts`:

       ```typescript
       export async function applyMerchantRuleRetroactively(
         prisma: any,
         userId: string,
         merchantPattern: string,
         category: string,
         merchantDisplay: string
       ): Promise<number> {
         try {
           // Update all transactions from this user with matching merchant
           // that were NOT manually categorized (preserve user intent)
           const result = await prisma.transaction.updateMany({
             where: {
               userId,
               categorySource: { notIn: ['manual'] },
               OR: [
                 { merchant: { contains: merchantPattern, mode: 'insensitive' } },
               ],
             },
             data: {
               category,
               categorySource: 'rule',
               categoryConfidence: 100,
             },
           });
           return result.count;
         } catch (error) {
           console.error('Retroactive re-categorization failed:', error);
           return 0;
         }
       }
       ```

       NOTE: We intentionally do NOT update the `merchant` display name in retroactive updates. The transaction's merchant field was set during import (already cleaned). Changing it retroactively could be confusing. Only the category, source, and confidence are updated.

       NOTE: `categorySource: { notIn: ['manual'] }` means we also re-categorize transactions that were 'ai', 'keyword', 'cache', or 'rule' (from a different, older rule). This is correct - only explicit user manual edits are sacred.

    2. Update `createOrUpdateMerchantRule` in the same file to call retroactive update after upserting the rule:

       After the existing `await prisma.merchantRule.upsert(...)` call and BEFORE the Redis cache invalidation, add:
       ```typescript
       // Apply rule retroactively to existing transactions
       const retroCount = await applyMerchantRuleRetroactively(
         prisma, userId, normalizedKey, category, displayName
       );
       if (retroCount > 0) {
         console.log(`Retroactively updated ${retroCount} transactions for merchant "${displayName}"`);
       }
       ```

       Update the return to include the count. Change the function return type and signature:
       ```typescript
       export async function createOrUpdateMerchantRule(
         prisma: any,
         userId: string,
         rawMerchant: string,
         category: string
       ): Promise<{ rule: any; retroactiveCount: number } | null> {
       ```

       Return `{ rule, retroactiveCount: retroCount }` instead of just `rule`.

    3. Update `spendwise-api/src/schema/resolvers/transaction.ts` to handle the new return type:

       In the `updateTransaction` mutation, where `createOrUpdateMerchantRule` is called (around line 257-259):
       ```typescript
       // Current:
       await createOrUpdateMerchantRule(context.prisma, user.id, merchant, input.category);
       // Change to:
       const ruleResult = await createOrUpdateMerchantRule(context.prisma, user.id, merchant, input.category);
       if (ruleResult && ruleResult.retroactiveCount > 0) {
         console.log(`Rule applied retroactively to ${ruleResult.retroactiveCount} transactions`);
       }
       ```

       In the `saveMerchantRule` mutation (around line 276-287):
       ```typescript
       // Current:
       const rule = await createOrUpdateMerchantRule(context.prisma, user.id, merchant, category);
       if (!rule) { throw new Error('...'); }
       return rule;
       // Change to:
       const result = await createOrUpdateMerchantRule(context.prisma, user.id, merchant, category);
       if (!result) { throw new Error('Failed to save merchant rule: invalid merchant name'); }
       return result.rule;
       ```

    4. Also add the `applyMerchantRuleRetroactively` import at the top of the transaction resolver:
       ```typescript
       import { createOrUpdateMerchantRule, getMerchantRules, deleteMerchantRule, applyMerchantRuleRetroactively } from '../../lib/merchant-rules';
       ```
       (Note: applyMerchantRuleRetroactively is called indirectly via createOrUpdateMerchantRule, but importing it makes the dependency explicit and allows direct use if needed later.)

       Actually, since `applyMerchantRuleRetroactively` is now called internally by `createOrUpdateMerchantRule`, we don't need to import it separately in the resolver. Just update the resolver to handle the new return type shape.

    IMPORTANT anti-pattern to avoid: Do NOT create merchant rules from automated re-categorization. Only user-initiated category changes (categorySource: 'manual') trigger rule creation. The existing code already does this correctly - the rule creation is only in `updateTransaction` when `input.category !== existing.category`. Do not change this guard.
  </action>
  <verify>
    - `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` compiles without errors
    - `grep "applyMerchantRuleRetroactively" /Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts` returns a match
    - `grep "retroactiveCount" /Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts` returns a match
    - `grep "notIn.*manual" /Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts` returns a match (preserves manual edits)
    - `grep "ruleResult\|result\.rule" /Users/heechung/projects/spendwise-api/src/schema/resolvers/transaction.ts` returns a match
    - Run existing tests: `cd /Users/heechung/projects/spendwise-api && npm test -- --passWithNoTests` passes
  </verify>
  <done>
    - `applyMerchantRuleRetroactively` function exists and is called when merchant rules are created/updated
    - Retroactive updates skip `categorySource: 'manual'` transactions (user intent preserved)
    - `createOrUpdateMerchantRule` returns both the rule and the retroactive count
    - Transaction resolver handles the new return type correctly
    - TypeScript compiles and existing tests pass
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` - TypeScript compiles
2. `cd /Users/heechung/projects/spendwise-api && npm test -- --passWithNoTests` - Tests pass
3. `grep "getUserCategoryHistory" /Users/heechung/projects/spendwise-api/src/lib/ai/categorizer.ts` - User history function exists
4. `grep "applyMerchantRuleRetroactively" /Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts` - Retroactive function exists
5. `grep "notIn.*manual" /Users/heechung/projects/spendwise-api/src/lib/merchant-rules.ts` - Manual edits are protected
</verification>

<success_criteria>
- CATG-03 (AI uses merchant + amount + user history): User's top 50 manual corrections are included in AI prompt
- CATG-05 (AI learns from corrections): Merchant rules are applied retroactively to existing transactions when created
- Manual categorizations are never overwritten by retroactive updates (categorySource: 'manual' is sacred)
- All changes are backward-compatible (no schema changes, no new dependencies)
</success_criteria>

<output>
After completion, create `/Users/heechung/projects/.planning/phases/02-ai-categorization-enhancement/02-02-SUMMARY.md`
</output>
