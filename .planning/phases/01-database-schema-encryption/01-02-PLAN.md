---
phase: 01-database-schema-encryption
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - spendwise-api/src/lib/prisma.ts
  - spendwise-api/package.json
  - spendwise-api/.env
  - spendwise-api/scripts/generate-encryption-key.ts
autonomous: true

must_haves:
  truths:
    - "Plaid access tokens stored via PlaidItem.create() are encrypted at rest in PostgreSQL"
    - "Plaid access tokens retrieved via PlaidItem.findUnique() are automatically decrypted"
    - "Encryption uses AES-256-GCM via prisma-field-encryption library"
    - "PRISMA_FIELD_ENCRYPTION_KEY environment variable is set and used"
    - "Existing Prisma queries for User, Account, Transaction, SavingsGoal continue to work unchanged"
  artifacts:
    - path: "spendwise-api/src/lib/prisma.ts"
      provides: "Prisma client with field encryption extension"
      contains: "fieldEncryptionExtension"
    - path: "spendwise-api/scripts/generate-encryption-key.ts"
      provides: "Utility script to generate AES-256 encryption keys"
      contains: "crypto.randomBytes"
    - path: "spendwise-api/.env"
      provides: "Environment with PRISMA_FIELD_ENCRYPTION_KEY"
      contains: "PRISMA_FIELD_ENCRYPTION_KEY"
  key_links:
    - from: "spendwise-api/src/lib/prisma.ts"
      to: "prisma-field-encryption"
      via: ".$extends(fieldEncryptionExtension())"
      pattern: "fieldEncryptionExtension"
    - from: "spendwise-api/src/lib/prisma.ts"
      to: "PlaidItem.accessToken"
      via: "transparent encryption on write, decryption on read"
      pattern: "\\$extends"
    - from: "spendwise-api/.env"
      to: "prisma-field-encryption"
      via: "PRISMA_FIELD_ENCRYPTION_KEY env var read by library"
      pattern: "PRISMA_FIELD_ENCRYPTION_KEY"
---

<objective>
Install and configure prisma-field-encryption for AES-256-GCM encryption of Plaid access tokens in the API service. Generate an encryption key and validate that encryption/decryption works transparently through the Prisma client.

Purpose: Fulfill CONN-10 requirement - Plaid access tokens must be encrypted at rest. This ensures sensitive financial credentials are never stored in plaintext in PostgreSQL.
Output: Working field-level encryption on PlaidItem.accessToken, key generation script, and environment configuration.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-schema-encryption/01-RESEARCH.md
@.planning/phases/01-database-schema-encryption/01-01-SUMMARY.md
@spendwise-api/src/lib/prisma.ts
@spendwise-api/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install prisma-field-encryption and configure encrypted Prisma client</name>
  <files>spendwise-api/package.json, spendwise-api/src/lib/prisma.ts, spendwise-api/scripts/generate-encryption-key.ts</files>
  <action>
1. Install prisma-field-encryption in the API project:
   `cd spendwise-api && npm install prisma-field-encryption`

2. Create a key generation script at `spendwise-api/scripts/generate-encryption-key.ts`:
   ```typescript
   import crypto from 'crypto';

   // Generate a 256-bit (32-byte) encryption key for AES-256-GCM
   // Used by prisma-field-encryption via PRISMA_FIELD_ENCRYPTION_KEY env var
   const key = crypto.randomBytes(32).toString('base64');
   console.log(`PRISMA_FIELD_ENCRYPTION_KEY=${key}`);
   console.log('\nAdd this to your .env file in spendwise-api/');
   console.log('IMPORTANT: Never commit this key to version control.');
   ```

3. Run the key generation script and capture the output:
   `cd spendwise-api && npx tsx scripts/generate-encryption-key.ts`

4. Add the generated `PRISMA_FIELD_ENCRYPTION_KEY=<generated-key>` to `spendwise-api/.env`. Add it after the existing environment variables. If `.env` doesn't exist, check `.env.example` for the template and create `.env` from it first.

   Also add a comment explaining the key:
   ```
   # Prisma field-level encryption key (AES-256-GCM)
   # Generate new key: npx tsx scripts/generate-encryption-key.ts
   # For key rotation, add old keys to PRISMA_FIELD_DECRYPTION_KEYS (comma-separated)
   PRISMA_FIELD_ENCRYPTION_KEY=<generated-key>
   ```

5. Update `spendwise-api/src/lib/prisma.ts` to use the encryption extension:

   Replace the current file contents with:
   ```typescript
   import { PrismaClient } from '@prisma/client';
   import { fieldEncryptionExtension } from 'prisma-field-encryption';

   declare global {
     // eslint-disable-next-line no-var
     var prisma: ReturnType<typeof createPrismaClient> | undefined;
   }

   function createPrismaClient() {
     const client = new PrismaClient({
       log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
     });

     return client.$extends(fieldEncryptionExtension());
   }

   export const prisma = global.prisma || createPrismaClient();

   if (process.env.NODE_ENV !== 'production') {
     global.prisma = prisma;
   }
   ```

   IMPORTANT: The `fieldEncryptionExtension()` reads `PRISMA_FIELD_ENCRYPTION_KEY` from `process.env` automatically. No need to pass the key explicitly.

   IMPORTANT: The return type changes from `PrismaClient` to the extended client type. If any imports elsewhere in the API use explicit `PrismaClient` typing, they may need updating. The context type in `src/context/index.ts` may reference `PrismaClient` - check if it needs updating to use `typeof prisma` instead.

6. Check `spendwise-api/src/context/index.ts` and any file that types the prisma client. If they import `PrismaClient` and use it as a type for the prisma instance, update them to use `typeof prisma` from `../lib/prisma` instead, OR keep the PrismaClient type but understand the extended methods are available at runtime even if not reflected in the type. The safest approach: use `typeof import('../lib/prisma').prisma` or keep existing types if they work (Prisma extensions are backwards-compatible with base PrismaClient type for all standard operations).
  </action>
  <verify>
1. `cd spendwise-api && npm ls prisma-field-encryption` shows the package installed
2. `cat spendwise-api/scripts/generate-encryption-key.ts` exists and contains crypto.randomBytes
3. `grep PRISMA_FIELD_ENCRYPTION_KEY spendwise-api/.env` shows the key is set (non-empty value)
4. `grep fieldEncryptionExtension spendwise-api/src/lib/prisma.ts` confirms extension is applied
5. `cd spendwise-api && npx tsc --noEmit` compiles without errors (or with only pre-existing errors)
  </verify>
  <done>
prisma-field-encryption installed, Prisma client extended with fieldEncryptionExtension(), encryption key generated and stored in .env, key generation script available at scripts/generate-encryption-key.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate encryption works end-to-end</name>
  <files>spendwise-api/scripts/validate-encryption.ts</files>
  <action>
Create a validation script at `spendwise-api/scripts/validate-encryption.ts` that proves encryption is working correctly. This script:

1. Creates a test PlaidItem with a known access token value
2. Reads the raw database row to verify the accessToken is encrypted (NOT plaintext)
3. Reads the PlaidItem through the Prisma client to verify it decrypts correctly
4. Cleans up the test data
5. Exits with status 0 on success, 1 on failure

```typescript
import { PrismaClient } from '@prisma/client';
import { fieldEncryptionExtension } from 'prisma-field-encryption';

async function validateEncryption() {
  // Extended client (encrypts/decrypts)
  const prisma = new PrismaClient().$extends(fieldEncryptionExtension());
  // Raw client (no encryption - reads raw database values)
  const rawPrisma = new PrismaClient();

  const testAccessToken = 'access-test-' + Date.now();
  const testPlaidItemId = 'test-item-' + Date.now();
  let testUserId: string | null = null;
  let testItemId: string | null = null;

  try {
    // 1. Get or create a test user
    let testUser = await rawPrisma.user.findFirst();
    if (!testUser) {
      testUser = await rawPrisma.user.create({
        data: {
          email: `encryption-test-${Date.now()}@test.com`,
          name: 'Encryption Test User',
        },
      });
      testUserId = testUser.id;
    }

    // 2. Create a PlaidItem with the encrypted client
    const item = await prisma.plaidItem.create({
      data: {
        userId: testUser.id,
        accessToken: testAccessToken,
        plaidItemId: testPlaidItemId,
        plaidInstitutionId: 'ins_test',
        institutionName: 'Test Bank',
      },
    });
    testItemId = item.id;
    console.log('Created PlaidItem with id:', item.id);

    // 3. Read raw database value (should be encrypted, NOT plaintext)
    const rawItem = await rawPrisma.plaidItem.findUnique({
      where: { id: item.id },
    });

    if (!rawItem) {
      throw new Error('FAIL: PlaidItem not found in database');
    }

    if (rawItem.accessToken === testAccessToken) {
      throw new Error(
        'FAIL: accessToken is stored in PLAINTEXT! Encryption is NOT working.'
      );
    }

    console.log('Raw DB value (encrypted):', rawItem.accessToken.substring(0, 50) + '...');
    console.log('PASS: accessToken is encrypted at rest');

    // 4. Read through encrypted client (should decrypt)
    const decryptedItem = await prisma.plaidItem.findUnique({
      where: { id: item.id },
    });

    if (!decryptedItem) {
      throw new Error('FAIL: Could not read PlaidItem through encrypted client');
    }

    if (decryptedItem.accessToken !== testAccessToken) {
      throw new Error(
        `FAIL: Decrypted value doesn't match. Expected: ${testAccessToken}, Got: ${decryptedItem.accessToken}`
      );
    }

    console.log('Decrypted value matches original');
    console.log('PASS: Encryption and decryption working correctly');

    // 5. Verify hash field is populated (if supported)
    if (rawItem.accessTokenHash) {
      console.log('PASS: accessTokenHash is populated for searchability');
    } else {
      console.log('INFO: accessTokenHash is null (may need explicit configuration)');
    }

    console.log('\n=== ALL ENCRYPTION VALIDATIONS PASSED ===');
  } catch (error) {
    console.error('\n=== ENCRYPTION VALIDATION FAILED ===');
    console.error(error);
    process.exit(1);
  } finally {
    // Cleanup
    if (testItemId) {
      await rawPrisma.plaidItem.delete({ where: { id: testItemId } }).catch(() => {});
    }
    if (testUserId) {
      await rawPrisma.user.delete({ where: { id: testUserId } }).catch(() => {});
    }
    await rawPrisma.$disconnect();
    process.exit(0);
  }
}

validateEncryption();
```

Run the validation:
`cd spendwise-api && npx tsx scripts/validate-encryption.ts`

The script MUST output "ALL ENCRYPTION VALIDATIONS PASSED" and exit with code 0.

If the validation fails because the database is not running, start it first:
`cd spendwise && docker-compose up -d`
Then wait a few seconds and retry.

Also verify that existing functionality is not broken by running existing tests:
`cd spendwise-api && npm test`

If tests fail due to the Prisma client type change (from PrismaClient to extended client), fix the type imports in test files to match the new client type. The most common fix is changing `PrismaClient` type annotations to use `typeof prisma` from the lib module.
  </action>
  <verify>
1. `cd spendwise-api && npx tsx scripts/validate-encryption.ts` outputs "ALL ENCRYPTION VALIDATIONS PASSED" and exits 0
2. The raw database value of accessToken is NOT the plaintext value (encrypted at rest)
3. The decrypted value through the Prisma client matches the original plaintext
4. `cd spendwise-api && npm test` passes (or has only pre-existing failures unrelated to this change)
  </verify>
  <done>
Encryption validated end-to-end: PlaidItem.accessToken is encrypted at rest in PostgreSQL (AES-256-GCM), transparently decrypted when read through the Prisma client with fieldEncryptionExtension. Existing API tests pass. Validation script available at scripts/validate-encryption.ts for future verification.
  </done>
</task>

</tasks>

<verification>
1. prisma-field-encryption is installed in spendwise-api
2. Prisma client in spendwise-api uses fieldEncryptionExtension()
3. PRISMA_FIELD_ENCRYPTION_KEY is set in spendwise-api/.env
4. Validation script proves accessToken is encrypted at rest and decrypts correctly
5. Existing API tests still pass
6. Key generation script exists for future key creation
</verification>

<success_criteria>
- prisma-field-encryption library installed and configured in spendwise-api
- PlaidItem.accessToken is encrypted at rest (AES-256-GCM) and transparently decrypted on read
- PRISMA_FIELD_ENCRYPTION_KEY environment variable is generated and configured
- Key generation utility script exists at scripts/generate-encryption-key.ts
- Encryption validation script exists at scripts/validate-encryption.ts and passes
- Existing API functionality is not broken by the Prisma client extension
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-schema-encryption/01-02-SUMMARY.md`
</output>
