---
phase: 03-spending-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - spendwise-api/src/schema/typeDefs/analytics.ts
  - spendwise-api/src/schema/resolvers/analytics.ts
  - spendwise-api/src/lib/utils.ts
autonomous: true

must_haves:
  truths:
    - "topMerchants query returns merchants sorted by total spending with frequency and averageAmount"
    - "analytics query accepts optional dateRange and accountIds parameters"
    - "analytics trends return multi-month time series data (6 months default) not single-period snapshots"
    - "month-over-month comparison returns percentage changes with proper edge case handling"
  artifacts:
    - path: "spendwise-api/src/schema/typeDefs/analytics.ts"
      provides: "MerchantSpending type, DateRangeInput, updated analytics and topMerchants queries"
      contains: "MerchantSpending"
    - path: "spendwise-api/src/schema/resolvers/analytics.ts"
      provides: "topMerchants resolver, enhanced analytics with date range, account filter, multi-month trends"
      exports: ["analyticsResolvers"]
    - path: "spendwise-api/src/lib/utils.ts"
      provides: "getMonthlyBuckets helper for time series generation"
      contains: "getMonthlyBuckets"
  key_links:
    - from: "spendwise-api/src/schema/resolvers/analytics.ts"
      to: "prisma.transaction.groupBy"
      via: "Prisma aggregation for merchant totals"
      pattern: "groupBy.*merchant"
    - from: "spendwise-api/src/schema/resolvers/analytics.ts"
      to: "redis cache"
      via: "getCache/setCache with user-scoped keys"
      pattern: "user:.*:merchants"
    - from: "spendwise-api/src/schema/resolvers/analytics.ts"
      to: "spendwise-api/src/lib/utils.ts"
      via: "getMonthlyBuckets import for trend data"
      pattern: "getMonthlyBuckets"
---

<objective>
Extend the GraphQL analytics API to support merchant analysis, flexible date range filtering, account filtering, and multi-month trend time series data.

Purpose: The existing analytics resolver only returns single-period snapshots with no merchant data, no date range input, and no account filtering. This plan adds the backend data layer needed by all five spending analysis requirements (SPND-01 through SPND-05).

Output: Enhanced analytics typeDefs and resolvers that serve all data needed for the spending analysis frontend.
</objective>

<execution_context>
@/Users/heechung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heechung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@spendwise-api/src/schema/typeDefs/analytics.ts
@spendwise-api/src/schema/resolvers/analytics.ts
@spendwise-api/src/lib/utils.ts
@spendwise/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add merchant analysis types and extend analytics query inputs</name>
  <files>
    spendwise-api/src/schema/typeDefs/analytics.ts
  </files>
  <action>
Extend the existing analytics GraphQL type definitions with the following additions:

1. Add a `DateRangeInput` input type:
   ```graphql
   input DateRangeInput {
     start: DateTime!
     end: DateTime!
   }
   ```

2. Add a `MerchantSpending` type:
   ```graphql
   type MerchantSpending {
     merchant: String!
     frequency: Int!
     totalAmount: Decimal!
     averageAmount: Decimal!
   }
   ```

3. Add a `topMerchants` query to the `extend type Query` block:
   ```graphql
   topMerchants(
     period: Period
     dateRange: DateRangeInput
     accountIds: [ID!]
     limit: Int = 10
   ): [MerchantSpending!]!
   ```

4. Update the existing `analytics` query signature to accept optional filtering:
   ```graphql
   analytics(
     period: Period = MONTH
     dateRange: DateRangeInput
     accountIds: [ID!]
   ): Analytics!
   ```

5. Update the existing `spendingByCategory` query to accept optional filtering:
   ```graphql
   spendingByCategory(
     period: Period = MONTH
     dateRange: DateRangeInput
     accountIds: [ID!]
   ): [CategoryAmount!]!
   ```

Keep all existing types (Analytics, DateRange, FinancialSummary, CategoryAmount, TrendData, PeriodComparison, DashboardStats) unchanged. Only ADD new types and UPDATE query signatures.
  </action>
  <verify>
Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` to verify TypeScript compilation succeeds with the new type definitions. Check for any import errors or type conflicts.
  </verify>
  <done>
GraphQL schema includes MerchantSpending type, DateRangeInput input, topMerchants query, and analytics/spendingByCategory queries accept dateRange and accountIds parameters.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement topMerchants resolver, enhance analytics with date range/account filtering and multi-month trends</name>
  <files>
    spendwise-api/src/schema/resolvers/analytics.ts
    spendwise-api/src/lib/utils.ts
  </files>
  <action>
**In spendwise-api/src/lib/utils.ts**, add a `getMonthlyBuckets` helper function at the end of the file:
```typescript
export function getMonthlyBuckets(startDate: Date, endDate: Date): Date[] {
  const buckets: Date[] = [];
  const current = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
  const end = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
  while (current <= end) {
    buckets.push(new Date(current));
    current.setMonth(current.getMonth() + 1);
  }
  return buckets;
}
```

**In spendwise-api/src/schema/resolvers/analytics.ts**, make these changes:

1. Import `getMonthlyBuckets` from `../../lib/utils`.

2. Add a helper function `getEffectiveDateRange` that accepts `(period?: Period, dateRange?: { start: string; end: string })` and returns `{ start: Date; end: Date }`. If `dateRange` is provided, parse its dates. Otherwise fall back to `getDateRange(period || 'MONTH')`.

3. Add a helper function `buildAccountFilter` that accepts `accountIds?: string[]` and returns `accountIds ? { accountId: { in: accountIds } } : {}`.

4. Add `topMerchants` resolver to `Query`:
   - Call `requireAuth(context)`
   - Build cache key: `user:${user.id}:merchants:${period || 'custom'}:${accountIds?.join(',') || 'all'}:${limit}`
   - Check cache with `getCache`
   - Get effective date range using `getEffectiveDateRange(period, dateRange)`
   - Use `context.prisma.transaction.groupBy` with:
     - `by: ['merchant']`
     - `where: { userId: user.id, type: 'EXPENSE', merchant: { not: null }, date: { gte: range.start, lte: range.end }, ...buildAccountFilter(accountIds) }`
     - `_sum: { amount: true }`
     - `_count: true`
     - `_avg: { amount: true }`
     - `orderBy: { _sum: { amount: 'desc' } }`
     - `take: limit`
   - Map results to `{ merchant: t.merchant!, frequency: t._count, totalAmount: parseDecimal(t._sum.amount), averageAmount: parseDecimal(t._avg.amount) }`
   - Cache for 900 seconds, return result

5. Update `analytics` resolver:
   - Change signature to accept `{ period, dateRange, accountIds }` instead of just `{ period }`
   - Update cache key to include accountIds: `user:${user.id}:analytics:${period || 'custom'}:${accountIds?.join(',') || 'all'}`
   - Use `getEffectiveDateRange(period, dateRange)` instead of `getDateRange(period)`
   - Add account filter to both transaction queries: `...buildAccountFilter(accountIds)`
   - **Replace the trends section** with multi-month time series:
     - Calculate 6-month range: `const trendStart = new Date(); trendStart.setMonth(trendStart.getMonth() - 5); trendStart.setDate(1); trendStart.setHours(0,0,0,0);`
     - Fetch all transactions in the 6-month range (with account filter if provided)
     - Use `getMonthlyBuckets(trendStart, dateRange.end)` to get month buckets
     - For each bucket, filter transactions within that month and sum income/expenses/savings
     - Format labels as `MMM yyyy` (e.g., "Sep 2025") using `toLocaleDateString('en-US', { month: 'short', year: 'numeric' })`
     - Return `{ labels, income: [...], expenses: [...], savings: [...] }` with one entry per month

6. Update `spendingByCategory` resolver:
   - Change signature to accept `{ period, dateRange, accountIds }`
   - Use `getEffectiveDateRange` and `buildAccountFilter` for filtering

**Edge cases to handle:**
- Division by zero in percentage calculations: use `totalExpenses > 0 ? ... : 0`
- Handle null `dateRange` and null `accountIds` gracefully (both optional)
- Ensure `merchant: { not: null }` in topMerchants to skip transactions without merchant data
- Cap percentage changes at reasonable bounds - if previous period value is 0, return 0 instead of Infinity
  </action>
  <verify>
1. Run `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit` - should compile without errors
2. Run `cd /Users/heechung/projects/spendwise-api && npm test` - existing tests should still pass
3. If API server can start: `cd /Users/heechung/projects/spendwise-api && timeout 10 npm run dev 2>&1 || true` - verify no startup errors
  </verify>
  <done>
- topMerchants resolver returns merchants sorted by total amount with frequency and average
- analytics resolver accepts dateRange and accountIds, returns 6-month multi-month trends
- spendingByCategory resolver accepts dateRange and accountIds
- All resolvers use Redis caching with appropriate cache keys
- Existing tests still pass
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd /Users/heechung/projects/spendwise-api && npx tsc --noEmit`
2. Tests pass: `cd /Users/heechung/projects/spendwise-api && npm test`
3. GraphQL schema is valid (no duplicate types, all referenced types exist)
4. Cache keys include all filter parameters to prevent stale cross-filter data
</verification>

<success_criteria>
- MerchantSpending type and topMerchants query exist in GraphQL schema
- analytics and spendingByCategory queries accept dateRange and accountIds
- analytics trends return 6 monthly data points (not single-period snapshot)
- topMerchants groups transactions by merchant with frequency, totalAmount, averageAmount
- All resolvers handle edge cases (null params, zero division, empty results)
- TypeScript compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-spending-analysis/03-01-SUMMARY.md`
</output>
